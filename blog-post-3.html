<!DOCTYPE html>
<html lang="en" prefix="og: http://ogp.me/ns# fb: https://www.facebook.com/2008/fbml">
<head>
    <title>То, что вы хотели знать про оптический поток, но стеснялись спросить - sergem personal public notebook</title>
    <!-- Using the latest rendering mode for IE -->
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">



<link rel="canonical" href="https://serge-m.github.io/blog-post-3.html">

        <meta name="author" content="SergeM" />
        <meta name="keywords" content="opencv,russian,optical flow" />
        <meta name="description" content="Взято с [http://habrahabr.ru/post/201406/](http://habrahabr.ru/post/201406/). Объяснение оптического потока из OpenCV для тех, кто не в теме и не очень хочет разобраться. Обработка изображений*, Алгоритмы* Оптический поток (Optical flow) – технология, использующаяся в различных областях computer vision для определения сдвигов, сегментации, выделения объектов, компрессии видео …" />

        <meta property="og:site_name" content="sergem personal public notebook" />
        <meta property="og:type" content="article"/>
        <meta property="og:title" content="То, что вы хотели знать про оптический поток, но стеснялись спросить"/>
        <meta property="og:url" content="https://serge-m.github.io/blog-post-3.html"/>
        <meta property="og:description" content="Взято с [http://habrahabr.ru/post/201406/](http://habrahabr.ru/post/201406/). Объяснение оптического потока из OpenCV для тех, кто не в теме и не очень хочет разобраться. Обработка изображений*, Алгоритмы* Оптический поток (Optical flow) – технология, использующаяся в различных областях computer vision для определения сдвигов, сегментации, выделения объектов, компрессии видео …"/>
        <meta property="article:published_time" content="2013-11-12" />
            <meta property="article:section" content="misc" />
            <meta property="article:tag" content="opencv" />
            <meta property="article:tag" content="russian" />
            <meta property="article:tag" content="optical flow" />
            <meta property="article:author" content="SergeM" />


    <!-- Bootstrap -->
        <link rel="stylesheet" href="https://serge-m.github.io/theme/css/bootstrap.min.css" type="text/css"/>
    <link href="https://serge-m.github.io/theme/css/font-awesome.min.css" rel="stylesheet">

    <link href="https://serge-m.github.io/theme/css/pygments/native.css" rel="stylesheet">
    <link rel="stylesheet" href="https://serge-m.github.io/theme/css/style.css" type="text/css"/>

        <link href="https://serge-m.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate"
              title="sergem personal public notebook ATOM Feed"/>

        <link href="https://serge-m.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate"
              title="sergem personal public notebook RSS Feed"/>


        <link href="https://serge-m.github.io/feeds/misc.atom.xml" type="application/atom+xml" rel="alternate"
              title="sergem personal public notebook misc ATOM Feed"/>

</head>
<body>

<div class="navbar navbar-default navbar-fixed-top" role="navigation">
	<div class="container">
        <div class="navbar-header">
            <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-ex1-collapse">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
            </button>
            <a href="https://serge-m.github.io/" class="navbar-brand">
sergem personal public notebook            </a>
        </div>
        <div class="collapse navbar-collapse navbar-ex1-collapse">
            <ul class="nav navbar-nav">
                        <li class="active">
                            <a href="https://serge-m.github.io/category/misc.html">Misc</a>
                        </li>
            </ul>
            <ul class="nav navbar-nav navbar-right">
            </ul>
        </div>
        <!-- /.navbar-collapse -->
    </div>
</div> <!-- /.navbar -->
<!-- Banner -->
<!-- End Banner -->
<div class="container">
    <div class="row">
        <div class="col-sm-9">
    <section id="content">
        <article>
            <header>
                <h1>
                    <a href="https://serge-m.github.io/blog-post-3.html"
                       rel="bookmark"
                       title="Permalink to То, что вы хотели знать про оптический поток, но стеснялись спросить">
                        То, что вы хотели знать про оптический поток, но стеснялись спросить
                    </a>
                </h1>
            </header>
            <div class="entry-content">
                <div class="panel">
<footer class="post-info">
    <span class="label label-default">Date</span>
    <span class="published">
        <i class="fa fa-calendar"></i><time datetime="2013-11-12T11:17:00+01:00"> 2013-11-12T11:17:00, Tue</time>
    </span>





<span class="label label-default">Tags</span>
	<a class="tag-list" href="https://serge-m.github.io/tag/opencv.html">opencv</a>
        /
	<a class="tag-list" href="https://serge-m.github.io/tag/russian.html">russian</a>
        /
	<a class="tag-list" href="https://serge-m.github.io/tag/optical-flow.html">optical flow</a>
    
</footer><!-- /.post-info -->                </div>
                <div dir="ltr" style="text-align: left;" trbidi="on">Взято с [http://habrahabr.ru/post/201406/](http://habrahabr.ru/post/201406/).
<div>Объяснение оптического потока из OpenCV для тех, кто не в теме и не очень хочет разобраться.
<div>
</div><div>
<div class="hubs" style="background-color: white; background-image: url(http://habrahabr.ru/images/posts/hub.icon.png); background-position: 0px 0px; background-repeat: no-repeat no-repeat; border: 0px; color: #999999; font-family: Verdana, sans-serif; font-size: 11px; margin: 0px 0px 15px; outline: 0px; padding: 2px 0px 2px 25px; vertical-align: baseline;"><a class="hub " href="http://habrahabr.ru/hub/image_processing/" style="border: 0px; color: #999999; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;" title="Вы не подписаны на этот хаб">Обработка изображений</a><span class="profiled_hub" style="border: 0px; cursor: help; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;" title="Профильный хаб">*</span>,&nbsp;<a class="hub " href="http://habrahabr.ru/hub/algorithms/" style="border: 0px; color: #999999; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;" title="Вы не подписаны на этот хаб">Алгоритмы</a><span class="profiled_hub" style="border: 0px; cursor: help; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;" title="Профильный хаб">*</span></div><div class="content html_format" style="background-color: white; border: 0px; font-family: Verdana, sans-serif; font-size: 13px; line-height: 20px; margin: 0px 0px 10px; outline: 0px; overflow: hidden; padding: 0px; vertical-align: baseline;"><img align="right" src="http://habr.habrastorage.org/post_images/6e7/202/488/6e7202488554327be02a3b211df4647a.jpg" style="border: 0px; margin: 5px 0px 5px 30px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
Оптический поток (Optical flow) – технология, использующаяся в различных областях computer vision для определения сдвигов, сегментации, выделения объектов, компрессии видео. Однако если мы захотим его по-быстрому реализовать в своем проекте, прочитав про него на википедии или где-нибудь еще, то, скорее всего, очень быстро наткнемся на то, что он работает очень плохо и сбоит при определении сдвигов уже порядка 1-2 пикселей (по крайней мере так было у меня). Тогда обратимся к готовым реализациям, например, в OpenCV. Там он реализован различными методами и совершенно непонятно, чем аббревиатура PyrLK лучше или хуже обозначения Farneback или чего-нибудь в этом роде, да и придется поразбираться со смыслом параметров, которых в некоторых реализациях очень много. Причем, что интересно, эти алгоритмы как-то работают, в отличие от того, что мы написали сами. В чем же секрет?
<a href="https://www.blogger.com/blogger.g?blogID=636453477220885924" name="habracut" style="border: 0px; color: #6da3bd; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;"></a>

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Что же такое оптический поток</h4>
Оптический поток (ОП) – изображение видимого движения, представляющее собой сдвиг каждой точки между двумя изображениями. По сути, он представляет собой поле скоростей (т. к. сдвиг с точностью до масштаба эквивалентен мгновенной скорости). Суть ОП в том, что для каждой точки изображения&nbsp;
![](http://latex.codecogs.com/gif.latex?I_{1}(x,y))
&nbsp;находится такой сдвиг (dx, dy), чтобы исходной точке соответствовала точка на втором изображении&nbsp;
![](http://latex.codecogs.com/gif.latex?I_{2}(x&amp;plus;dx,y&amp;plus;dy))
. Как определить соответствие точек – отдельный вопрос. Для этого надо взять какую-то функцию точки, которая не изменяется в результате смещения. Обычно считается, что у точки сохраняется интенсивность (т. е. яркость или цвет для цветных изображений), но можно считать одинаковыми точки, у которых сохраняется величина градиента, гессиан, его величина или его определитель, лапласиан, другие характеристики. Очевидно, сохранение интенсивности дает сбои, если меняется освещенность или угол падения света. Тем не менее, если речь идет о видеопотоке, то, скорее всего, между двумя кадрами освещение сильно не изменится, хотя бы потому, что между ними проходит малый промежуток времени. Поэтому часто используют интенсивность в качестве функции, сохраняющейся у точки.

По такому описанию можно перепутать ОП с поиском и сопоставлением характерных точек. Но это разные вещи, суть оптического потока в том, что он не ищет какие-то особенные точки, а по параметрам изображений пытается определить, куда сместилась произвольная точка.

Есть два варианта расчета оптического потока: плотный (dense) и выборочный (sparse). Sparse поток рассчитывает сдвиг отдельных заданных точек (например, точек, выделенных некоторым feature detector'ом), dense поток считает сдвиг всех точек изображения. Естественно, выборочный поток вычисляется быстрее, однако для некоторых алгоритмов разница не такая уж и большая, а для некоторых задач требуется нахождение потока во всех точках изображения.

Для вырожденных случаев можно применять более простые методы определения сдвига. В частности, если все точки изображения имеют один и тот же сдвиг (изображение сдвинуто целиком), то можно применить метод фазовой корреляции: вычислить преобразование Фурье для обоих изображений, найти свертку их фаз и по ней определить сдвиг (см.[en.wikipedia.org/wiki/Phase_correlation](http://en.wikipedia.org/wiki/Phase_correlation" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)). Также можно применять поблочное сравнение (block matching): находить сдвиг, минимизирующий норму разности изображений в окне. В чистом виде такой алгоритм будет работать долго и неустойчиво к поворотам и прочим искажениям.&nbsp;[Английская википедия](http://en.wikipedia.org/wiki/Optical_flow" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)&nbsp;причисляет перечисленные алгоритмы к различным вариантам вычисления оптического потока, но мне это кажется не слишком корректным, так как эти алгоритмы могут быть применены и в других целях и не полностью решают данную задачу. Мы будем называть оптическим потоком методы, основанные на локальных характеристиках изображений (то, что в английской википедии называется differential methods).

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Стандартный подход (метод Лукаса-Канаде)</h4>
Математическое описание алгоритма достаточно подробно приведено в&nbsp;[этой статье](http://habrahabr.ru/post/169055/" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;), но в ней затрагиваются лишь теоретические аспекты.

Рассмотрим математическую модель оптического потока, считая, что у точки в результате смещения не изменилась интенсивность.

Пусть&nbsp;<img src="http://habr.habrastorage.org/post_images/fd3/055/cea/fd3055ceaa3ac999993187efe591cc42.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;– интенсивность в некоторой точке (x, y) на первом изображении (т. е. в момент времени t). На втором изображении эта точка сдвинулась на (dx, dy), при этом прошло время dt, тогда&nbsp;<img src="http://habr.habrastorage.org/post_images/d80/ad7/750/d80ad77501aec2e45d1b199cabe7db55.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;– это мы разложили по Тейлору функцию интенсивности до первого члена (позже будет упомянуто, почему только до первого), здесь&nbsp;
![](http://latex.codecogs.com/gif.latex?I_{x},I_{y},I_{t})
&nbsp;– частные производные по координатам и времени, то есть по сути&nbsp;
![](http://latex.codecogs.com/gif.latex?I_{t}dt)
&nbsp;– изменение яркости в точке (x, y) между двумя кадрами.

Мы считаем, что у точки сохранилась интенсивность, значит&nbsp;
![](http://latex.codecogs.com/gif.latex?I_{1}=I_{2}\Rightarrow)
&nbsp;<img src="http://habr.habrastorage.org/post_images/240/a53/130/240a531308dcc6d61a797f29f0d09b7d.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
Получаем одно уравнение с двумя неизвестными (dx и dy), значит его недостаточно для решения, то есть только на этом уравнении далеко не уедешь.

Самое простое решение проблемы – алгоритм Лукаса-Канаде. У нас же на изображении объекты размером больше 1 пикселя, значит, скорее всего, в окрестности текущей точки у других точек будут примерно такие же сдвиги. Поэтому мы возьмем окно вокруг этой точки и минимизируем (по МНК) в нем суммарную погрешность с весовыми коэффициентами, распределенными по Гауссу, то есть так, чтобы наибольший вес имели пиксели, ближе всего находящиеся к исследуемому. После простейших преобразований, получаем уже систему из 2 уравнений с 2 неизвестными:&nbsp;<img src="http://habr.habrastorage.org/post_images/0ce/761/7f0/0ce7617f00672f62bc3b8819af66f72d.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
<img src="http://habr.habrastorage.org/post_images/f56/644/5aa/f566445aa7c1524c856f73396a28dea5.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
Как известно, эта система имеет единственное решение не всегда (хотя и очень часто): если детерминант системы равен нулю, то решений либо нет, либо бесконечное число. Эта проблема известна как Aperture problem – неоднозначность сдвига при ограниченном поле зрения для периодических картинок. Она соответствует случаю, когда в поле зрения попадает фрагмент изображения, в котором присутствует некоторая цикличность; тут уж и человек не сможет однозначно определить, куда картинка сместилась. Проблема в том, что из-за шумов в таких неоднозначных ситуациях мы получим не нулевой детерминант, а очень маленький, который, скорее всего, приведет к очень большим значениям сдвига, особо не коррелирующим с действительностью. Так что на определенном этапе нужно просто проверять, не является ли детерминант системы достаточно маленьким, и, если что, не рассматривать такие точки или отмечать их как ошибочные.

<h5 style="border: 0px; color: #999999; font-size: 14px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Почему не работает?</h5>
Если мы остановимся на этом этапе и реализуем этот алгоритм, то он будет успешно работать. Но только если сдвиг между соседними изображениями будет очень маленький, порядка 1 пикселя, и то не всегда. (Для анализа качества генерировались синтетические последовательности с различным относительным сдвигом, причем этот сдвиг может выражаться нецелым числом пикселей, тогда результирующее изображение соответствующим образом интерполируется) Уже на сдвиге в 2 пикселя погрешность будет большая, а если 3 и более, то результат будет вообще неадекватным. В чем же дело?

Тут нам устроила подставу математика. Она привила нам ощущение, что все функции вокруг непрерывные и много раз дифференцируемые. И вообще нас в институте приучили приближение функции в окрестности точки записывать с помощью формулы Тейлора, и мы везде&nbsp;<s style="border: 0px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">бездумно</s>&nbsp;радостно пользуемся этим. А теперь задумаемся, какой физический смысл производных в данном месте? Мы хотим с их помощью определить изменение значения функции в конечной окрестности точки, а производная дает представление о бесконечно малой окрестности. Для расширения этой окрестности можно было бы добавить более высокий порядок производных в разложение Тейлора, но это приведет к нелинейностям в системе, от чего ее станет существенно сложнее решать, а преимущества будут сомнительны, тем более что на практике мы имеем дело не с непрерывными многократно дифференцируемыми функциями, а с вообще непонятно какими дискретными функциями. Поэтому логичнее будет искать функцию g(x), для которой в нашем дискретном случае как можно точнее выполняется f(x) + g(x) = f(x+1), f(x) + 2g(x) = f(x+2), f(x) — g(x) = f(x-1), и т. д. Таким образом, нам в этом случае нужна не производная, а некоторая линейная функция, наиболее близко лежащая к точкам исходной функции. Простые математические выкладки приводят к решению&nbsp;<img src="http://habr.habrastorage.org/post_images/873/fc4/f2e/873fc4f2ef7f7bc8cc586734f2e1eeb6.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />, где&nbsp;<img src="http://habr.habrastorage.org/post_images/5e3/400/fb2/5e3400fb2e1b01aad1ad4c61fc1f286a.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />. Если мы строили производную по одной соседней точке с каждой стороны, то нам повезло: в этом случае формула совпадает с формулой приближенного вычисления производных: g(x) = (f(x+1) – f(x-1)) / 2. Что характерно, в OpenCV при вычислении оптического потока Лукаса-Канаде используется именно такая формула, к этому мы еще вернемся потом. А вот если взять больше точек, то формула уже становится совсем не похожа на классические разностные схемы для первой производной.

Очевидно, если мы строим эту функцию, например, по трем окрестным точкам слева и справа от исходной, то она никаким образом не зависит от точек, расположенных дальше, и, соответственно, при сдвиге более трех точек все равно у нас часто будут получаться неадекватные результаты. А еще, чем больше число точек, по которым мы строим эту функцию, тем больше среднее отклонение получаемой линии от используемых точек – опять же из-за того, что у нас не линейно меняющиеся изображения, а черт знает какие. На практике сдвиги более 2 пикселей уже дают неадекватно большую ошибку, сколько бы точек мы ни взяли.

Другим слабым местом алгоритма является то, что мы опять же имеем дело не с гладкими непрерывными функциями, а с произвольными, да еще и дискретными. Поэтому на некоторых фрагментах изображения интенсивность может «скакать» вообще без явных закономерностей, например на границах объектов, или из-за шумов. В этом случае никакая функция g(x) не сможет достаточно точно описать изменения изображения в окрестности точки. Чтобы с этим побороться (хотя бы частично), предлагается исходное изображение размазать, причем полезно будет его размазать достаточно сильно, то есть лучше применять даже не всеми любимый gaussian blur (усреднение с весовыми коэффициентами), а прямо таки box filter (равномерное усреднение по окну), да еще и несколько раз подряд. Гладкость изображения для нас сейчас важнее, чем детализация.

Тем не менее, эти меры так же не спасут нас от ограничения детектируемого сдвига в 2-3 пикселя. И кстати, в OpenCV 1.0 присутствовала такая реализация оптического потока, и работала она только в идеальных условиях на очень маленьких сдвигах.

<h5 style="border: 0px; color: #999999; font-size: 14px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Что же делать?</h5>
Итого, обычный Лукас-Канаде хорошо определяет маленькие сдвиги, такие, в рамках которых картинка похожа на свое линейное приближение. Чтобы с этим побороться, воспользуемся стандартным приемом CV – multi-scaling'ом: построим «пирамиду» изображений разного масштаба (почти всегда берется масштабирование в 2 раза по каждой оси, так проще считать) и пройдем по ним оптическим потоком от меньшего изображения к большему, тогда детектированный маленький сдвиг на маленьком изображении будет соответствовать большому сдвигу на большом изображении. На самом маленьком изображении мы обнаруживаем сдвиг не более 1-2 пикселей, а переходя от меньшего масштаба к большему, мы пользуемся результатом с предыдущего шага и уточняем значения сдвига. Собственно, в OpenCV его и реализует функция calcOptFlowPyrLK. Использование этого пирамидального алгоритма позволяет нам не заморачиваться вычислением линейной аппроксимации по многим точкам: проще взять больше уровней пирамиды, а на каждом уровне брать довольно грубое приближение этой функции. Поэтому в OpenCV и идет расчет всего по двум соседним точкам. И поэтому применительно к этой реализации алгоритма наши умозаключения про преимущество аппроксимирующей функции перед производной оказались бесполезными: для такого количества опорных точек производная и есть лучшая аппроксимирующая функция.

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">А какие еще бывают?</h4>
Этот алгоритм не является единственным вариантом вычисления оптического потока. В OpenCV кроме потока Лукаса-Канаде есть еще поток Farneback и SimpleFlow, также часто ссылаются на алгоритм Horn–Schunck.

Метод&nbsp;<b style="border: 0px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Horn–Schunck</b>&nbsp;носит несколько более глобальный характер, чем метод Лукаса-Канаде. Он опирается на предположение о том, что на всем изображении оптический поток будет достаточно гладким. От того же самого уравнения&nbsp;<img src="http://habr.habrastorage.org/post_images/240/a53/130/240a531308dcc6d61a797f29f0d09b7d.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;предлагается перейти к функционалу&nbsp;<img src="http://habr.habrastorage.org/post_images/408/f58/8d3/408f588d3cb05bc7382f837ecc8ecf20.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />, то есть добавить требование на отсутствие резкого изменения сдвигов с весовым коэффициентом α. Минимизация этого функционала приводит нас к системе из двух уравнений:
<img src="http://habr.habrastorage.org/post_images/17e/fbc/79a/17efbc79aea908239ef99a47018bce6e.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
<img src="http://habr.habrastorage.org/post_images/f38/e8c/b3a/f38e8cb3adc643694b4e08559e55d798.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />

В этих уравнениях лапласиан предлагают посчитать приближенно:&nbsp;<img src="http://habr.habrastorage.org/post_images/e82/489/c96/e82489c96f4090512dfa656998a04c2f.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;– разница со средним значением. Получаем систему уравнений, которую записываем для каждого пикселя и решаем общую систему итеративно:
<img src="http://habr.habrastorage.org/post_images/a34/68c/2e9/a3468c2e91b7c7e4f44cdd51b13f170a.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
<img src="http://habr.habrastorage.org/post_images/152/655/864/152655864a0daca7ecaf8baba9077b7a.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />

В данном алгоритме тоже предлагают использовать multi-scaling, причем рекомендуют масштабировать изображения не в 2 раза, а с коэффициентом 0.65

Этот алгоритм был реализован в первых версиях OpenCV, но в последствии от него отказались.

<b style="border: 0px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Farneback&nbsp;</b>предложил аппроксимировать изменение интенсивности в окрестности с помощью квадратичной формы: I = xAx + bx + c с симметричной матрицей A (по сути, рассматривая разложение по Тейлору до первого члена, мы брали линейную аппроксимацию I = bx + c, то есть сейчас мы как раз решили повысить точность приближения) Если изображение сдвинулось в пределах этой окрестности, то&nbsp;<img src="http://habr.habrastorage.org/post_images/cef/f63/791/ceff6379139b144d6d2c290118c7c8d5.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />, подставляем в квадратичное разложение, раскрываем скобки, получаем
<img src="http://habr.habrastorage.org/post_images/090/fa5/838/090fa58384ab43497db73237eb3a988e.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
<img src="http://habr.habrastorage.org/post_images/030/eba/ae7/030ebaae7c37805e0be02defef7b4244.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />
<img src="http://habr.habrastorage.org/post_images/9d4/449/ebb/9d4449ebb384df15ef0853676772cdc9.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />.

Теперь мы можем вычислить значения A, b, c на обеих картинках, и тогда эта система станет избыточной относительно d (особенно смущает первое уравнение), и вообще d можно получить из второго уравнения:&nbsp;<img src="http://habr.habrastorage.org/post_images/ef8/7cf/c7d/ef87cfc7d6261d21a899cf835ab7df3a.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />. Приходится прибегать к следующей аппроксимации:&nbsp;<img src="http://habr.habrastorage.org/post_images/203/301/bf3/203301bf395673df883b82488e29ca14.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />. Обозначим еще для простоты&nbsp;<img src="http://habr.habrastorage.org/post_images/b37/4b0/d2f/b374b0d2f529418ef08c5def9fe659b7.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />, Тогда получим просто&nbsp;<img src="http://habr.habrastorage.org/post_images/b43/4e2/d0c/b434e2d0c3ae8e29e4249dc5c9aed27d.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />.

Для компенсации шумов при вычислении, снова обратимся к тому предположению, что в окрестности исследуемой точки у всех точек более или менее одинаковый сдвиг. Поэтому опять же проинтегрируем погрешность<img src="http://habr.habrastorage.org/post_images/a7e/62d/483/a7e62d48343e482228cf72e68de75445.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;по окну с гауссовскими весовыми коэффициентами&nbsp;<i style="border: 0px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">w</i>, и найдем вектор d, минимизирующий эту суммарную погрешность. Тогда мы получим оптимальное значение&nbsp;<img src="http://habr.habrastorage.org/post_images/771/272/648/77127264820430245399b7c058413ed9.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;и соответствующую минимальную ошибку&nbsp;<img src="http://habr.habrastorage.org/post_images/202/f32/3c0/202f323c016171111b818ae08b97ef6f.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />. То есть нам надо для каждой точки посчитать&nbsp;<img src="http://habr.habrastorage.org/post_images/98d/eec/6dd/98deec6ddd703117053247522a2da8af.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />, усреднить по окну, инвертировать матрицу и получить результат. Соответственно эти произведения можно посчитать для всей картинки и использовать заранее рассчитанные значения для разных точек, то есть это как раз тот случай, когда имеет смысл считать dense поток.

Как обычно, у этого алгоритма есть некоторое количество модификаций и усовершенствований, в первую очередь позволяющих использовать известную априорную информацию – заданную начальную аппроксимацию потока – и, опять же, multi-scaling.

В основе метода&nbsp;<b style="border: 0px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">SimpleFlow</b>&nbsp;лежит следующая идея: если мы все равно не умеем определять сдвиг больше чем размер окна, по которому мы искали производные, то зачем вообще заморачиваться с вычислением производных? Давайте просто в окне найдем наиболее похожую точку! А для разрешения неоднозначностей и для компенсации шумов учтем, что поток непрерывный и в окрестности данной точки все точки имеют почти одинаковый сдвиг. А проблему с размером окна опять же решим за счет multi-scaling'а.

Более строго, алгоритм звучит так: для всех точек в окне находится функция «энергии», отвечающая (с обратной логарифмической зависимостью) за вероятность перехода исходной точки в эту точку:&nbsp;<img src="http://habr.habrastorage.org/post_images/95a/5bb/1f2/95a5bb1f2de9ef34b6c376a4e85c3003.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />. Далее, считается свертка этой энергии с гауссовым окном&nbsp;<img src="http://habr.habrastorage.org/post_images/829/bd8/f54/829bd8f541609108d50d8bd269f146de.gif" style="border: 0px; margin: 0px; max-width: 100%; outline: 0px; padding: 0px; vertical-align: middle;" />&nbsp;и находятся значения (dx,dy), минимизирующие эту функцию. Чтобы получить субпиксельную точность, рассматривается малая окрестность найденной оптимальной точки (dx,dy) и в ней ищется пик функции энергии как пик параболоида. И, как было упомянуто выше, эта процедура выполняется для пирамиды масштабированных изображений. Еще у них в алгоритме предложены хитрые методы ускорения расчетов, но это уже кому интересно разберутся сами. Для нас же важно, что за счет этого данный алгоритм является (теоретически) достаточно быстрым при неплохой точности. И у него нет такой проблемы, как у предыдущих, что чем больше сдвиг, тем хуже он детектируется.

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">А если брать не интенсивность?</h4>
Выше было сказано, что соответствие между точками может определяться разными величинами, так почему же мы рассматриваем только интенсивность? А потому, что любую другую величину можно свести к ней: мы просто фильтруем изображения соответствующим фильтром и на вход описанных выше алгоритмов подаем отфильтрованные изображения. Соответственно, если вы хотите использовать оптический поток, то сначала подумайте, в ваших условиях какая характеристика изображения будет наиболее стабильной, и проведите соответствующую фильтрацию, чтобы на входе алгоритма оказалась не интенсивность, а эта характеристика.

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Практика</h4>
Давайте опробуем на практике алгоритмы, которые нам предлагает OpenCV.

Здесь можно проводить множество различных исследований каждого алгоритма, варьируя параметры, изменяя входные последовательности – с разными сдвигами, поворотами, проективными преобразованиями, сегментами, с разными шумами и т. д. Это все заняло бы уйму времени и по размеру отчета превзошло бы настоящую статью, поэтому здесь предлагаю ограничиться простым случаем параллельного сдвига изображения на фиксированное расстояние и наложение небольших шумов. Это позволит понять в общих чертах, как запускать алгоритмы и кто из них круче.

Подробно синтаксис процедур описан на странице с&nbsp;[мануалом](http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;), здесь я приведу выжимку-перевод с моими комментариями.

Классический Лукас-Канаде реализован с пирамидой в процедуре calcOpticalFlowPyrLK. Алгоритм рассчитывает sparse-поток, то есть для заданного набора точек на первом изображении оценивает их положение на втором. Входные параметры достаточно очевидны: два входных изображения, входной и выходной наборы точек, status – выходной вектор, показывающий, найдена ли успешно соответствующая точка, err – выходной вектор оцененных погрешностей соответствующих точек, WinSize – размер окна, по которому происходит гауссово усреднение, я брал 21х21 и работало хорошо, maxLevel – количество слоев в пирамиде минус один, т. е. номер последнего слоя, я брал 5, criteria – условие выхода из итеративного процесса определения сдвига (минимизация погрешности производится итеративно) – этот параметр я оставлял по умолчанию, flags – дополнительные флаги, например можно использовать начальное приближение потока или выбрать метод оценки погрешности, minEigThreshold – пороговое значение градиента, ниже которого матрица считается вырожденной, я оставлял по умолчанию. Начиная с OpenCV 2.4.1, при вычислении потока можно использовать заранее вычисленную пирамиду отмасштабированных изображений.

Результат работы – успешно и стабильно обнаруживаются как малые, так и большие сдвиги, устойчив к довольно большим шумам, время работы – порядка 10 мс для 400 точек c 5-слойной пирамидой (на core i7 950).

Кстати, этот алгоритм реализован так же на Gpu (CUDA), причем как dense, так и sparse версии.

Поток Farneback реализуется процедурой calcOpticalFlowFarneback, рассчитывается dense-поток, то есть сдвиг каждой точки. Параметры: входные изображения, выходной поток в формате двухканальной матрицы float'ов, pyr_scale определяет отношение масштабов между слоями пирамиды, levels – количество уровней в пирамиде, winsize – размер окна, по которому производится усреднение, iterations – количество итераций на каждом уровне, poly_n – размер полинома, по которому оцениваются значения A и b, poly_sigma – сигма гауссовского размытия при сглаживании производных, рекомендованные значения параметров указаны в мануале, flags – дополнительные флаги, например можно использовать начальное приближение потока или по-другому усреднять по окну.

Этот алгоритм куда менее стабилен (по моим наблюдениям), легче промахивается на довольно равномерных картинках (видимо, проблема в отсутствии фильтрации неудачных точек), плохо определяет большие сдвиги. У меня отрабатывал за 600 мс на изображении 512х512.

Поток SimpleFlow реализует процедура calcOpticalFlowSF (рассчитывается опять же dense поток), и у нее есть множество загадочных параметров без дефолтных значений, и вообще на данный момент на странице информация предоставлена весьма лаконично. Попробуем разобраться. Первые 3 – входные изображения и выходное двухканальное; layers – количество слоев в пирамиде, то есть сколько раз масштабируем исходное изображение; averaging_block_size – размер окна, в котором мы считали функцию энергии пикселей; max_flow – максимальный сдвиг, который мы хотим уметь определять на каждом шаге, по сути он определяется размером окна (хотя не совсем понятно, почему он int). На этом можно остановиться, а можно задать еще несколько параметров, смысл некоторых из них от меня ускользает.

На сайте предлагают посмотреть&nbsp;[пример](https://github.com/Itseez/opencv/blob/master/samples/cpp/simpleflow_demo.cpp" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)&nbsp;его использования, в котором он запускается с такими параметрами: calcOpticalFlowSF(frame1, frame2, flow, 3, 2, 4, 4.1, 25.5, 18, 55.0, 25.5, 0.35, 18, 55.0, 25.5, 10);

У меня алгоритм работает значительно медленнее других, порядка 9-12 секунд на картинку 512х512. Результат работы кажется более правдоподобным, чем Farneback, по крайней мере лучше определяется сдвиг на равномерных картинках, заметно лучше срабатывает с большими сдвигами.

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Выводы</h4>
Если вы хотите использовать где-то оптический поток, сначала подумайте, нужен ли он вам: часто можно обойтись более простыми методами. Браться реализовывать поток самостоятельно стоит только несколько раз подумав: каждый алгоритм имеет множество хитростей, тонкостей и оптимизаций; что бы вы ни сделали, скорее всего, в OpenCV оно же работает лучше (естественно, при условии, что оно там есть). Тем более что они там вовсю используют логические и хардварные оптимизации типа использования SSE инструкций, многопоточность, возможности вычисления с CUDA или OpenCL и т. д. Если вам достаточно посчитать сдвиг некоторого набора точек (т. е. sparse поток), то можете смело использовать функцию calcOpticalFlowPyrLK, оно работает хорошо, надежно и достаточно быстро. Для вычисления dense-потока хорошо использовать функцию calcOpticalFlowSF, но она работает очень медленно. Если быстродействие критично, то calcOpticalFlowFarneback, но надо еще удостовериться, что результаты его работы вас устроят.

<h4 style="border: 0px; color: #999999; font-size: 16px; font-weight: normal; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">Литература</h4>
[docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html](http://docs.opencv.org/modules/video/doc/motion_analysis_and_object_tracking.html" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)
Pyramidal Implementation of the Lucas Kanade Feature Tracker. Description of the algorithm — Jean-Yves Bouguet
Two-Frame Motion Estimation Based on Polynomial Expansion — Gunnar Farneback
SimpleFlow: A Non-iterative, Sublinear Optical Flow Algorithm — Michael Tao, Jiamin Bai, Pushmeet Kohli, and Sylvain Paris
Horn-Schunck Optical Flow with a Multi-Scale Strategy — Enric Meinhardt-Llopis, Javier Sanchez
[en.wikipedia.org/wiki/Optical_flow](http://en.wikipedia.org/wiki/Optical_flow" style="border: 0px; color: #990099; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)
<div class="clear" style="border: 0px; clear: both; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;"></div></div><ul class="tags" style="background-attachment: scroll; background-color: white; background-image: url(http://habrahabr.ru/images/bg-tags2.gif); background-position: 0px 50%; background-repeat: no-repeat no-repeat; border: 0px; font-family: Verdana, sans-serif; font-size: 10px; list-style: none; margin: 0px 0px 15px; outline: 0px; padding: 2px 0px 2px 20px; vertical-align: baseline;"><li style="border: 0px; color: #999999; display: inline; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">[оптический поток](http://habrahabr.ru/search/?q=%5B%D0%BE%D0%BF%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9%20%D0%BF%D0%BE%D1%82%D0%BE%D0%BA%5D&amp;target_type=posts" rel="tag" style="border: 0px; color: #666666; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)</li><li style="border: 0px; color: #999999; display: inline; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">,&nbsp;[optical flow](http://habrahabr.ru/search/?q=%5Boptical%20flow%5D&amp;target_type=posts" rel="tag" style="border: 0px; color: #666666; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)</li><li style="border: 0px; color: #999999; display: inline; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">,&nbsp;[computer vision](http://habrahabr.ru/search/?q=%5Bcomputer%20vision%5D&amp;target_type=posts" rel="tag" style="border: 0px; color: #666666; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)</li><li style="border: 0px; color: #999999; display: inline; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;">,&nbsp;[openCV](http://habrahabr.ru/search/?q=%5BopenCV%5D&amp;target_type=posts" rel="tag" style="border: 0px; color: #666666; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;)</li></ul><div class="infopanel_wrapper" style="background-color: white; border: 0px; font-family: Verdana, sans-serif; font-size: 12px; margin: 0px; outline: 0px; padding: 0px; vertical-align: baseline;"><div class="infopanel " id="infopanel_post_201406" style="border-bottom-left-radius: 5px; border-bottom-right-radius: 5px; border-top-left-radius: 5px; border-top-right-radius: 5px; border: 1px solid rgb(229, 229, 229); display: inline-block; font-family: Arial, sans-serif; font-size: 11px; margin: 0px; outline: 0px; padding: 0px 10px; vertical-align: middle;"><div class="voting   " style="border: 0px; float: left; margin: 6px 26px 6px 0px; outline: 0px; padding: 0px 20px; position: relative; vertical-align: baseline;"></div></div></div></div></div></div>
            </div>
            <!-- /.entry-content -->
    <hr/>
    <section class="comments" id="comments">
        <h2>Comments</h2>

        <div id="disqus_thread"></div>
        <script type="text/javascript">
            /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
            var disqus_shortname = 'serge-m-github-io'; // required: replace example with your forum shortname

                    var disqus_identifier = 'blog-post-3';
                var disqus_url = 'https://serge-m.github.io/blog-post-3.html';

            var disqus_config = function () {
                this.language = "en";
            };

            /* * * DON'T EDIT BELOW THIS LINE * * */
            (function () {
                var dsq = document.createElement('script');
                dsq.type = 'text/javascript';
                dsq.async = true;
                dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
            })();
        </script>
        <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by
            Disqus.</a></noscript>
        <a href="http://disqus.com" class="dsq-brlink">comments powered by <span class="logo-disqus">Disqus</span></a>

    </section>
        </article>
    </section>

        </div>
        <div class="col-sm-3" id="sidebar">
            <aside>
<!-- Sidebar -->
<section class="well well-sm">
  <ul class="list-group list-group-flush">

<!-- Sidebar/Recent Posts -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Recent Posts</span></h4>
  <ul class="list-group" id="recentposts">
    <li class="list-group-item"><a href="https://serge-m.github.io/disk-usage-ubuntu.html">Reducing disk usage in Ubuntu</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/spark-in-docker-with-aws-credentials.html">Spark in Docker with AWS credentials</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/okrs.html">OKRs</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/bokeh-example.html">Bokeh in jupyter notebooks for interactive plots</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/click-config-parsers.html">Comparison of click-based config parsers for python</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/vim.html">Vim cheat sheet</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/presentations-in-browser.html">Presentaitons in browser</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/print-lines-matching-regex.html">Select lines matching regular expression in python</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/airflow.html">Workflow management with Apache Airflow</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/datetime-in-python.html">Datetime in Python</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/flask-and-sqlalchemy-explained.html">Flask and SQLAlchemy explained</a></li>
    <li class="list-group-item"><a href="https://serge-m.github.io/ubuntu-linux-settings.html">Ubuntu linux settings</a></li>
  </ul>
</li>
<!-- End Sidebar/Recent Posts -->

<!-- Sidebar/Categories -->
<li class="list-group-item">
  <h4><i class="fa fa-home fa-lg"></i><span class="icon-label">Categories</span></h4>
  <ul class="list-group" id="categories">
    <li class="list-group-item">
      <a href="https://serge-m.github.io/category/misc.html"><i class="fa fa-folder-open fa-lg"></i>misc</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Categories -->

<!-- Sidebar/Tag Cloud -->
<li class="list-group-item">
  <a href="https://serge-m.github.io/"><h4><i class="fa fa-tags fa-lg"></i><span class="icon-label">Tags</span></h4></a>
  <ul class="list-group list-inline tagcloud" id="tags">
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/after-effects-aae.html">after effects (aae)</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/algorithm-performance.html">algorithm performance</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/argparse.html">argparse</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/avconv.html">avconv</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/best-practices.html">best practices</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/bokeh.html">bokeh</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/books.html">books</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="https://serge-m.github.io/tag/c.html">c++</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/calendar.html">calendar</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/celery.html">celery</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/cheatsheet.html">cheatsheet</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/clang.html">clang</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/click.html">click</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/command-line.html">command line</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/comparison.html">comparison</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/connexion.html">connexion</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/console.html">console</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/cplusplus11.html">cplusplus11</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/cpp.html">cpp</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/data.html">data</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/date.html">date</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/deep-learning.html">deep learning</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/depth-map.html">depth map</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/disk-usage.html">disk usage</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/dll.html">dll</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/docker.html">docker</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/en.html">en</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/errors.html">errors</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/ffmpeg.html">ffmpeg</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/firefox.html">firefox</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/flask.html">flask</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/git.html">git</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/html.html">html</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/ideas.html">ideas</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/image.html">image</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/image-processing.html">image processing</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/images.html">images</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/interview.html">interview</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/ipython.html">ipython</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/java.html">java</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/java8.html">java8</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/javascript.html">javascript</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/laplacian.html">Laplacian</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/latex.html">latex</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/links.html">links</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="https://serge-m.github.io/tag/linux.html">linux</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/linux-for-dummies.html">Linux for dummies</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/linux-mint.html">linux mint</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/logging.html">logging</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/logs.html">logs</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/machine-learning.html">machine learning</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/make.html">make</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/management.html">management</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/matlab.html">matlab</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/memory.html">memory</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/mildly-interesting.html">mildly interesting</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/mixins.html">mixins</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/network.html">network</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/nuke.html">nuke</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/numpy.html">numpy</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/obsolete.html">obsolete</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/opencv.html">opencv</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/openvpn.html">openvpn</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/optical-flow.html">optical flow</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/parallel.html">parallel</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/pelican.html">pelican</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/pi.html">pi</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/presentations.html">presentations</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/project-management.html">project management</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/pwm.html">pwm</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/pypy.html">pypy</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/pytest.html">pytest</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="https://serge-m.github.io/tag/python.html">python</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/raspberry.html">raspberry</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/raspberry-pi.html">raspberry pi</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/rest.html">REST</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/russian.html">russian</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/sarcasm.html">sarcasm</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/search.html">search</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/server.html">server</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/software.html">software</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/sql.html">sql</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/ssh.html">ssh</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/ssim.html">ssim</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/sublime.html">sublime</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/tensorflow.html">tensorflow</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/testing.html">testing</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/tests.html">tests</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/tools.html">tools</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/travisci.html">travisci</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/ubuntu.html">ubuntu</a>
    </li>
    <li class="list-group-item tag-1">
      <a href="https://serge-m.github.io/tag/useful.html">useful</a>
    </li>
    <li class="list-group-item tag-2">
      <a href="https://serge-m.github.io/tag/video.html">video</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/video-processing.html">video processing</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/vim.html">vim</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/visual-studio.html">visual studio</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/web.html">web</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/windows.html">windows</a>
    </li>
    <li class="list-group-item tag-4">
      <a href="https://serge-m.github.io/tag/workaround.html">workaround</a>
    </li>
    <li class="list-group-item tag-3">
      <a href="https://serge-m.github.io/tag/youtube.html">youtube</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Tag Cloud -->

<!-- Sidebar/Links -->
<li class="list-group-item">
  <h4><i class="fa fa-external-link-square fa-lg"></i><span class="icon-label">Links</span></h4>
  <ul class="list-group" id="links">
    <li class="list-group-item">
      <a href="/pages/collection-of-interesting-databases.html" target="_blank">Databases</a>
    </li>
    <li class="list-group-item">
      <a href="/pages/posts-by-year.html" target="_blank">Posts by year</a>
    </li>
    <li class="list-group-item">
      <a href="/books.html" target="_blank">Books</a>
    </li>
    <li class="list-group-item">
      <a href="/tag/useful.html" target="_blank">Useful</a>
    </li>
    <li class="list-group-item">
      <a href="/bjontegaard-metric-matlab-script.html" target="_blank">Bjontegaard metric in Matlab</a>
    </li>
    <li class="list-group-item">
      <a href="feeds/all.rss.xml" target="_blank">RSS</a>
    </li>
    <li class="list-group-item">
      <a href="feeds/all.atom.xml" target="_blank">Atom</a>
    </li>
  </ul>
</li>
<!-- End Sidebar/Links -->
  </ul>
</section>
<!-- End Sidebar -->            </aside>
        </div>
    </div>
</div>
<footer>
   <div class="container">
      <hr>
      <div class="row">
         <div class="col-xs-10">&copy; 2018 sergem
            &middot; 
            <small><a href="http://platformxy.com">platformxy.com</a>, <a href="http://lock.platformxy.com">lock</a></small>         </div>
         <div class="col-xs-2"><p class="pull-right"><i class="fa fa-arrow-up"></i> <a href="#">Back to top</a></p></div>
      </div>
   </div>
</footer>
<script src="https://serge-m.github.io/theme/js/jquery.min.js"></script>

<!-- Include all compiled plugins (below), or include individual files as needed -->
<script src="https://serge-m.github.io/theme/js/bootstrap.min.js"></script>

<!-- Enable responsive features in IE8 with Respond.js (https://github.com/scottjehl/Respond) -->
<script src="https://serge-m.github.io/theme/js/respond.min.js"></script>

    <!-- Disqus -->
    <script type="text/javascript">
        /* * * CONFIGURATION VARIABLES: EDIT BEFORE PASTING INTO YOUR WEBPAGE * * */
        var disqus_shortname = 'serge-m-github-io'; // required: replace example with your forum shortname

        /* * * DON'T EDIT BELOW THIS LINE * * */
        (function () {
            var s = document.createElement('script');
            s.async = true;
            s.type = 'text/javascript';
            s.src = '//' + disqus_shortname + '.disqus.com/count.js';
            (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
        }());
    </script>
    <!-- End Disqus Code -->
    <!-- Google Analytics -->
    <script type="text/javascript">

        var _gaq = _gaq || [];
        _gaq.push(['_setAccount', 'UA-40853494-2']);
        _gaq.push(['_trackPageview']);

        (function () {
            var ga = document.createElement('script');
            ga.type = 'text/javascript';
            ga.async = true;
            ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
            var s = document.getElementsByTagName('script')[0];
            s.parentNode.insertBefore(ga, s);
        })();
    </script>
    <!-- End Google Analytics Code -->


</body>
</html>