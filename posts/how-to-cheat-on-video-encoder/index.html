<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>How to cheat on video encoder comparisons | sergem&#39;s personal public notebook</title>
<meta name="keywords" content="" />
<meta name="description" content="Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472&#34; target=&#34;_blank)Filed under:&nbsp;[benchmark](http://x264dev.multimedia.cx/archives/category/benchmark&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in benchmark),[H.264](http://x264dev.multimedia.cx/archives/category/h264&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in H.264),[stupidity](http://x264dev.multimedia.cx/archives/category/stupidity&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in stupidity),[test sequences](http://x264dev.multimedia.cx/archives/category/test-sequences&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in test sequences)&nbsp;::Over the past few years, practically everyone and their dog has published some sort of encoder comparison.&nbsp; Sometimes they’re actually intended to be something for the world to rely on, like the old Doom9 comparisons and the MSU comparisons.">
<meta name="author" content="SergeM">
<link rel="canonical" href="https://serge-m.github.io/posts/how-to-cheat-on-video-encoder/" />
<link href="/assets/css/stylesheet.min.4a7c1baa41934a41353b5c02dd9ecd335d4e6b47f3fa5a187a77574ac682b8ac.css" integrity="sha256-SnwbqkGTSkE1O1wC3Z7NM11Oa0fz&#43;loYendXSsaCuKw=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://serge-m.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://serge-m.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://serge-m.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://serge-m.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://serge-m.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.82.0" />

<script type="application/javascript">
var doNotTrack = false;
if (!doNotTrack) {
	(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
	(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
	m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
	})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
	ga('create', 'UA-40853494-2', 'auto');
	
	ga('send', 'pageview');
}
</script><meta property="og:title" content="How to cheat on video encoder comparisons" />
<meta property="og:description" content="Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472&#34; target=&#34;_blank)Filed under:&nbsp;[benchmark](http://x264dev.multimedia.cx/archives/category/benchmark&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in benchmark),[H.264](http://x264dev.multimedia.cx/archives/category/h264&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in H.264),[stupidity](http://x264dev.multimedia.cx/archives/category/stupidity&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in stupidity),[test sequences](http://x264dev.multimedia.cx/archives/category/test-sequences&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in test sequences)&nbsp;::Over the past few years, practically everyone and their dog has published some sort of encoder comparison.&nbsp; Sometimes they’re actually intended to be something for the world to rely on, like the old Doom9 comparisons and the MSU comparisons." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://serge-m.github.io/posts/how-to-cheat-on-video-encoder/" /><meta property="og:image" content="https://serge-m.github.io/papermod-cover.png"/><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2013-10-11T12:57:00&#43;00:00" />
<meta property="article:modified_time" content="2013-10-11T12:57:00&#43;00:00" />

<meta name="twitter:card" content="summary_large_image"/>
<meta name="twitter:image" content="https://serge-m.github.io/papermod-cover.png"/>

<meta name="twitter:title" content="How to cheat on video encoder comparisons"/>
<meta name="twitter:description" content="Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472&#34; target=&#34;_blank)Filed under:&nbsp;[benchmark](http://x264dev.multimedia.cx/archives/category/benchmark&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in benchmark),[H.264](http://x264dev.multimedia.cx/archives/category/h264&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in H.264),[stupidity](http://x264dev.multimedia.cx/archives/category/stupidity&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in stupidity),[test sequences](http://x264dev.multimedia.cx/archives/category/test-sequences&#34; rel=&#34;category tag&#34; style=&#34;letter-spacing: 0px;&#34; title=&#34;View all posts in test sequences)&nbsp;::Over the past few years, practically everyone and their dog has published some sort of encoder comparison.&nbsp; Sometimes they’re actually intended to be something for the world to rely on, like the old Doom9 comparisons and the MSU comparisons."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://serge-m.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "How to cheat on video encoder comparisons",
      "item": "https://serge-m.github.io/posts/how-to-cheat-on-video-encoder/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "How to cheat on video encoder comparisons",
  "name": "How to cheat on video encoder comparisons",
  "description": "Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472\" target=\"_blank)Filed under:\u0026nbsp;[benchmark](http://x264dev.multimedia.cx/archives/category/benchmark\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in benchmark),[H.264](http://x264dev.multimedia.cx/archives/category/h264\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in H.264),[stupidity](http://x264dev.multimedia.cx/archives/category/stupidity\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in stupidity),[test sequences](http://x264dev.multimedia.cx/archives/category/test-sequences\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in test sequences)\u0026nbsp;::Over the past few years, practically everyone and their dog has published some sort of encoder comparison.\u0026nbsp; Sometimes they’re actually intended to be something for the world to rely on, like the old Doom9 comparisons and the MSU comparisons.",
  "keywords": [
    
  ],
  "articleBody": "Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472\" target=\"_blank)Filed under: [benchmark](http://x264dev.multimedia.cx/archives/category/benchmark\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in benchmark),[H.264](http://x264dev.multimedia.cx/archives/category/h264\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in H.264),[stupidity](http://x264dev.multimedia.cx/archives/category/stupidity\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in stupidity),[test sequences](http://x264dev.multimedia.cx/archives/category/test-sequences\" rel=\"category tag\" style=\"letter-spacing: 0px;\" title=\"View all posts in test sequences) ::Over the past few years, practically everyone and their dog has published some sort of encoder comparison. Sometimes they’re actually intended to be something for the world to rely on, like the old Doom9 comparisons and the MSU comparisons. Other times, they’re just to scratch an itch — someone wants to decide for themselves what is better. And sometimes they’re just there to outright lie in favor of whatever encoder the author likes best. The latter is practically an expected feature on the websites of commercial encoder vendors. One thing almost all these comparisons have in common — particularly (but not limited to!) the ones done without consulting experts — is that they are horribly done. They’re usually easy to spot: for example, two videos at totally different bitrates are being compared, or the author complains about one of the videos being “washed out” (i.e. he screwed up his colorspace conversion). Or the results are simply nonsensical. Many of these problems result from the person running the test not “sanity checking” the results to catch mistakes that he made in his test. Others are just outright intentional. The result of all these mistakes, both intentional and accidental, is that the results of encoder comparisons tend to be all over the map, to the point of absurdity. For any pair of encoders, it’s practically a given that a comparison exists somewhere that will “prove” any result you want to claim, even if the result would be beyond impossible in any sane situation. This often results in the appearance of a “controversy” even if there isn’t any. Keep in mind that every single mistake I mention in this article has actually been done, usually in more than one comparison. And before I offend anyone, keep in mind that when I say “cheating”, I don’t mean to imply that everyone that makes the mistake is doing it intentionally. Especially among amateur comparisons, most of the mistakes are probably honest. So, without further ado, we will investigate a wide variety of ways, from the blatant to the subtle, with which you too can cheat on your encoder comparisons.   Blatant cheating 1. Screw up your colorspace conversions. A common misconception is that converting from YUV to RGB and back is a simple process where nothing can go wrong. This is quite untrue. There are two primary attributes of YUV: PC range (0-255) vs TV range (16-235) and BT.709 vs BT.601 conversion coefficients. That sums up to a total of 4 possible different types of YUV. When people compare encoders, they often use different frontends, some of which make incorrect assumptions about these attributes. Incorrect assumptions are so common that it’s often a matter of luck whether the tool gets it right or not. It doesn’t help that most videos don’t even properly signal which they are to begin with! Often even the tool that the person running the comparison is using to view the source material gets the conversion wrong. Subsampling YUV (aka what everyone uses) adds yet another dimension to the problem: the locations which the chroma data represents (“chroma siting”) isn’t constant. For example, JPEG and MPEG-2 define different positions. This is even worse because almost nobody actually handles this correctly — the best approach is to simply make sure none of your software is doing any conversion. A mistake in chroma siting is what created that infamous PSNR graph showing Theora beating x264, which has been cited for ages since despite the developers themselves retracting it after realizing their mistake. Keep in mind that the video encoder is not responsible for colorspace conversion — almost all video encoders operate in the YUV domain (usually subsampled 4:2:0 YUV, aka YV12). Thus any problem in colorspace conversion is usually the fault of the tools used, not the actual encoder. How to spot it: “The color is a bit off” or “the contrast of the video is a bit duller”. There were a staggering number of “H.264 vs Theora” encoder comparisons which came out in favor of one or the other solely based on “how well the encoder kept the color” — making the results entirely bogus. 2. Don’t compare at the same (or nearly the same) bitrate. I saw a VP8 vs x264 comparison the other day that gave VP8 30% more bitrate and then proceeded to demonstrate that it got better PSNR. You would think this is blindingly obvious, but people still make this mistake! The most common cause of this is assuming that encoders will successfully reach the target bitrate you ask of them — particularly with very broken encoders that don’t. Always check the output filesizes of your encodes. How to spot it: The comparison lists perfectly round bitrates for every single test, as opposed to the actual bitrates achieved by the encoders, which will never be exactly matching in any real test. 3. Use unfair encoding settings. This is a bit of a wide topic: there are many ways to do this. We’ll cover the more blatant ones in this part. Here’s some common ones: a. Simply cheat. Intentionally pick awful settings for the encoder you don’t like. b. Don’t consider performance. Pick encoding settings without any regard for some particular performance goal. For example, it’s perfectly reasonable to say “use the best settings possible, regardless of speed”. It’s also reasonable to look for a particular encoding speed target. But what isn’t reasonable is to pick extremely fast settings for one encoder and extremely slow settings for another encoder. c. Don’t attempt match compatibility options when it’s reasonable to do so. Keyframe interval is a classic one of these: shorter values reduce compression but improve seeking. An easy way to cheat is to simply not set them to the same value, biasing towards whatever encoder has the longer interval. This is most common as an accidental mistake with comparisons involving ffmpeg, where the default keyframe interval is an insanely low 12 frames. How to spot it: The comparison doesn’t document its approach regarding choice of encoding settings. 4. Use ratecontrol methods unfairly. Constant bitrate is not the same as average bitrate — using one instead of the other is a great way to completely ruin a comparison. Another method is to use 1-pass bitrate mode for one encoder and 2-pass or constant quality for another. A good general approach is that, for any given encoder, one should use 2-pass if available and constant quality if not (it may take a few runs to get the bitrate you want, of course). Of course, it’s also fine to run a comparison with a particular mode in mind — for example, a comparison targeted at streaming applications might want to test using 1-pass CBR. Of course, in such a case, if CBR is not available in an encoder, you can’t compare to that encoder. How to spot it: It’s usually pretty obvious if the encoding settings are given. 5. Use incredibly old versions of encoders. As it happens, Debian stable is not the best source for the most recent encoding software. Equally, using recent versions known to be buggy. 6. Don’t distinguish between video formats and the software that encodes them. This is incredibly common: I’ve seen tests that claim to compare “H.264″ against something else while in fact actually comparing “Quicktime” against something else. It’s impossible to compare all H.264 encoders at once, so don’t even try — just call the comparison “Quicktime versus X” instead of “H.264 versus X”. Or better yet, use a good H.264 encoder, like x264 and don’t bother testing awful encoders to begin with. Less-obvious cheating1. Pick a bitrate that’s way too low. Low bitrate testing is very effective at making differences between encoders obvious, particularly if doing a visual comparison. But past a certain point, it becomes impossible for some encoders to keep up. This is usually an artifact of the video format itself — a scalability limitation. Practically all DCT-based formats have this kind of limitation (wavelets are mostly immune). In reality, this is rarely a problem, because one could merely downscale the video to resolve the problem — lower resolutions need fewer bits. But people rarely do this in comparisons (it’s hard to do it fairly), so the best approach is to simply not use absurdly low bitrates. What is “absurdly low”? That’s a hard question — it ends up being a matter of using one’s best judgement. This tends to be less of a problem in larger-scale tests that use many different bitrates. How to spot it: At least one of the encoders being compared falls apart completely and utterly in the screenshots. Biases towards, a lot: Video formats with completely scalable coding methods (Dirac, Snow, JPEG-2000, SVC). Biases towards, a little: Video formats with coding methods that improve scalability, such as arithmetic coding, B-frames, and run-length coding. For example, H.264 and Theora tend to be more scalable than MPEG-4. 2. Pick a bitrate that’s way too high. This is staggeringly common mistake: pick a bitrate so high that all of the resulting encodes look absolutely perfect. The claim is then made that “there’s no significant difference” between any of the encoders tested. This is surprisingly easy to do inadvertently on sources like Big Buck Bunny, which looks transparent at relatively low bitrates. An equally common but similar mistake is to test at a bitrate that isn’t so high that the videos look perfect, but high enough that they all look very good. The claim is then made that “the difference between these encoders is small”. Well, of course, if you give everything tons of bitrate, the difference between encoders is small. How to spot it: You can’t tell which image is the source and which is the encode. 3. [Making invalid comparisons using objective metrics](http://x264dev.multimedia.cx/?p=458\" target=\"_blank). I explained this earlier in the linked blog post, but in short, if you’re going to measure PSNR, make sure all the encoders are optimized for PSNR. Equally, if you’re going to leave the encoder optimized for visual quality, don’t measure PSNR — post screenshots instead. Same with SSIM or any other objective metric. Furthermore, don’t blindly do metric comparisons — always at least look at the output as a sanity test. Finally, do not claim that PSNR is particularly representative of visual quality, because it isn’t. How to spot it: Encoders with psy optimizations, such as x264 or Theora 1.2, do considerably worse than expected in PSNR tests, but look much better in visual comparisons. 4. Lying with graphs. Using misleading scales on graphs is a great way to make the differences between encoders seem larger or smaller than they actually are. A common mistake is to scale SSIM linearly: in fact, 0.99 is about twice as good as 0.98, not 1% better. One solution for this is to use db to compare SSIM values. 5. Using lossy screenshots. Posting screenshots as JPEG is a silly, pointless way to worsen an encoder comparison. Subtle cheating1. Unfairly pick screenshots for comparison. Comparing based on stills is not ideal, but it’s often vastly easier than comparing videos in motion. But it also opens up the door to unfairness. One of the most common mistakes is to pick a frame immediately after (or on) a keyframe for one encoder, but which isn’t for the other encoder. Particularly in the case of encoders that massively boost keyframe quality, this will unfairly bias in favor of the one with the recent keyframe. How to spot it: It’s very difficult to tell, if not impossible, unless they provide the video files to inspect. 2. Cherry-pick source videos. Good source videos are incredibly hard to come by — almost everything is already compressed and what’s left is usually a very poor example of real content. Here’s some common ways to bias unfairly using cherry-picking: a. Pick source videos that are already heavily compressed. Pre-compressed source isn’t much of an issue if your target quality level for testing is much lower than that of the source, since any compression artifacts in the source will be a lot smaller than those created by the encoders. But if the source is already very compressed, or you’re testing at a relatively high quality level, this becomes a significant issue. Biases towards: Anything that uses a similar transform to the source content. For MPEG-2 source material, this biases towards formats that use the 8x8dct or a very close approximation: MPEG-1/2/4, H.263, and Theora. For H.264 source material, this biases towards formats that use a 4×4 transform: H.264 and VP8. b. Pick standard test clips that were not intended for this purpose. There are a wide variety of uncompressed “[standard test clips](http://media.xiph.org/video/derf/\" target=\"_blank)“. Some of these are not intended for general-purpose use, but rather exist to test specific encoder capabilities. For example, Mobile Calendar (“mobcal”) is extremely sharp and low motion, serving to test interpolation capabilities. It will bias incredibly heavily towards whatever encoder uses more B-frames and/or has higher-precision motion compensation. Other test clips are almost completely static, such as the classic “akiyo”. These are also not particularly representative of real content. c. Pick very noisy content. Noise is — by definition — not particularly compressible. Both in terms of PSNR and visual quality, a very noisy test clip will tend to reduce the differences between encoders dramatically. d. Pick a test clip to exercise a specific encoder feature. I’ve often used short clips from [Touhou games](http://x264.nl/developers/Dark_Shikari/Flash/saextra.html\" target=\"_blank) to demonstrate the effectiveness of x264′s macroblock-tree algorithm. I’ve sometimes even used it to compare to other encoders as part of such a demonstration. I’ve also used the standard test clip “parkrun” as a demonstration of adaptive quantization. But claiming that either is representative of most real content — and thus can be used as a general determinant of how good encoders are — is of course insane. e. Simply encode a bunch of videos and pick the one your favorite encoder does best on. 3. Preprocessing the source. A encoder test is a test of encoders, not preprocessing. Some encoding apps may add preprocessors to the source, such as noise reduction. This may make the video look better — possibly even better than the source — but it’s not a fair part of comparing the actual encoders. 4. Screw up decoding. People often forget that in addition to encoding, a test also involves decoding — a step which is equally possible to do wrong. One common error caused by this is in tests of Theora on content whose resolution isn’t divisible by 16. Decoding is often done with ffmpeg — which doesn’t crop the edges properly in some cases. This isn’t really a big deal visually, but in a PSNR comparison, misaligning the entire frame by 4 or 8 pixels is a great way of completely invalidating the results. The greatest mistake of allAbove all, the biggest and most common mistake — and the one that leads to many of the problems mentioned here – is the mistaken belief that one, or even a few tests can really represent all usage fairly. Any comparison has to have some specific goal — to compare something in some particular case, whether it be “maximum offline compression ignoring encoding speed” or “real-time high-speed video streaming” or whatnot. And even then, no comparison can represent all use-cases in that category alone. An encoder comparison can only be honest if it’s aware of its limitations. ",
  "wordCount" : "2573",
  "inLanguage": "en",
  "datePublished": "2013-10-11T12:57:00Z",
  "dateModified": "2013-10-11T12:57:00Z",
  "author":{
    "@type": "Person",
    "name": "SergeM"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://serge-m.github.io/posts/how-to-cheat-on-video-encoder/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "sergem's personal public notebook",
    "logo": {
      "@type": "ImageObject",
      "url": "https://serge-m.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://serge-m.github.io/" accesskey="h" title="Home (Alt + H)">Home</a>
            <span class="logo-switches">
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://serge-m.github.io/archives" title="Archive">
                    <span>Archive</span>
                </a>
            </li>
            <li>
                <a href="https://serge-m.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://serge-m.github.io/search/" title="Search (Alt &#43; /)" accesskey=/>
                    <span>Search</span>
                </a>
            </li>
            <li>
                <a href="https://serge-m.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://serge-m.github.io/">Home</a>&nbsp;»&nbsp;<a href="https://serge-m.github.io/posts/">Posts</a></div>
    <h1 class="post-title">
      How to cheat on video encoder comparisons
    </h1>
    <div class="post-meta">October 11, 2013&nbsp;·&nbsp;SergeM
</div>
  </header> <div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <div class="details">Table of Contents</div>
        </summary>
        <div class="inner"><ul>
                <li>
                    <a href="#post-472" aria-label="Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472&#34; target=&#34;_blank)">Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472" target="_blank)</a></li>
                <li>
                    <a href="#" aria-label="Less-obvious cheating"><strong style="background-color: white;">Less-obvious cheating</strong></a></li>
                <li>
                    <a href="#" aria-label="Subtle cheating"><strong style="background-color: white;">Subtle cheating</strong></a></li>
                <li>
                    <a href="#" aria-label="The greatest mistake of all"><strong style="background-color: white;">The greatest mistake of all</strong></a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><div dir="ltr" style="text-align: left;" trbidi="on"><h3 class="storytitle" id="post-472" style="font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Trebuchet MS', Verdana, Helvetica, sans-serif; font-size: 1.3em; margin-bottom: 2px; margin-top: 10px; padding-bottom: 0px;">Source:[Diary Of An x264 Developer](http://x264dev.multimedia.cx/archives/472" target="_blank)</h3><h3 class="storytitle" id="post-472" style="font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Trebuchet MS', Verdana, Helvetica, sans-serif; font-size: 1.3em; margin-bottom: 2px; margin-top: 10px; padding-bottom: 0px;"></h3><div class="meta" style="font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Trebuchet MS', Verdana, Helvetica, sans-serif; font-size: 0.8em;"><span style="background-color: white;">Filed under:&nbsp;[benchmark](http://x264dev.multimedia.cx/archives/category/benchmark" rel="category tag" style="letter-spacing: 0px;" title="View all posts in benchmark),[H.264](http://x264dev.multimedia.cx/archives/category/h264" rel="category tag" style="letter-spacing: 0px;" title="View all posts in H.264),[stupidity](http://x264dev.multimedia.cx/archives/category/stupidity" rel="category tag" style="letter-spacing: 0px;" title="View all posts in stupidity),[test sequences](http://x264dev.multimedia.cx/archives/category/test-sequences" rel="category tag" style="letter-spacing: 0px;" title="View all posts in test sequences)&nbsp;::</span></div><div class="storycontent" style="font-family: 'Lucida Grande', 'Lucida Sans Unicode', 'Trebuchet MS', Verdana, Helvetica, sans-serif;"><span style="background-color: white;">Over the past few years, practically everyone and their dog has published some sort of encoder comparison.&nbsp; Sometimes they’re actually intended to be something for the world to rely on, like the old Doom9 comparisons and the MSU comparisons.&nbsp; Other times, they’re just to scratch an itch — someone wants to decide for themselves what is better.&nbsp; And sometimes they’re just there to outright lie in favor of whatever encoder the author likes best.&nbsp; The latter is practically an&nbsp;<em>expected feature</em>&nbsp;on the websites of commercial encoder vendors.</span>
<span style="background-color: white;">One thing almost all these comparisons have in common — particularly (but not limited to!) the ones done without consulting experts — is that they are horribly done.&nbsp; They’re usually easy to spot: for example, two videos at totally different bitrates are being compared, or the author complains about one of the videos being “washed out” (i.e. he screwed up his colorspace conversion).&nbsp; Or the results are simply nonsensical.&nbsp; Many of these problems result from the person running the test not “sanity checking” the results to catch mistakes that he made in his test.&nbsp; Others are just outright intentional.</span>
<span style="background-color: white;">The result of all these mistakes, both intentional and accidental, is that the results of encoder comparisons tend to be all over the map, to the point of absurdity.&nbsp; For any pair of encoders, it’s practically a given that a comparison exists somewhere that will “prove” any result you want to claim, even if the result would be beyond impossible in any sane situation.&nbsp; This often results in the appearance of a “controversy” even if there isn’t any.</span>
<span style="background-color: white;">Keep in mind that every single mistake I mention in this article&nbsp;<strong>has actually been done</strong>, usually in more than one comparison.&nbsp; And before I offend anyone, keep in mind that when I say “cheating”, I don’t mean to imply that everyone that makes the mistake is doing it intentionally.&nbsp; Especially among amateur comparisons, most of the mistakes are probably honest.</span>
<span style="background-color: white;">So, without further ado, we will investigate a wide variety of ways, from the blatant to the subtle, with which you too can cheat on your encoder comparisons.</span>
<span style="background-color: white;">
</span><span style="background-color: white;"></span>
<span style="background-color: white;">
</span>
<span style="background-color: white;">
</span><strong>Blatant cheating</strong><span style="background-color: white;"></span>
<span style="background-color: white;"><strong>1.&nbsp; Screw up your colorspace conversions</strong>.&nbsp; A common misconception is that converting from YUV to RGB and back is a simple process where nothing can go wrong.&nbsp; This is quite untrue. There are two primary attributes of YUV: PC range (0-255) vs TV range (16-235) and BT.709 vs BT.601 conversion coefficients.&nbsp; That sums up to a total of 4 possible different types of YUV.&nbsp; When people compare encoders, they often use different frontends, some of which make incorrect assumptions about these attributes.</span>
<span style="background-color: white;">Incorrect assumptions are so common that it’s often a matter of luck whether the tool gets it right or not.&nbsp; It doesn’t help that most videos don’t even properly signal which they are to begin with!&nbsp; Often even the tool that the person running the comparison is using to view the source material gets the conversion wrong.</span>
<span style="background-color: white;">Subsampling YUV (aka what everyone uses) adds yet another dimension to the problem: the locations which the chroma data represents (“chroma siting”) isn’t constant.&nbsp; For example, JPEG and MPEG-2 define different positions.&nbsp; This is even worse because almost nobody actually handles this correctly — the best approach is to simply make sure none of your software is doing any conversion.&nbsp; A mistake in chroma siting is what created that infamous PSNR graph showing Theora beating x264, which has been cited for ages since despite the developers themselves retracting it after realizing their mistake.</span>
<strong style="background-color: white;">Keep in mind that the video encoder is not responsible for colorspace conversion — almost all video encoders operate in the YUV domain (usually subsampled 4:2:0 YUV, aka YV12).&nbsp; Thus any problem in colorspace conversion is usually the fault of the tools used, not the actual encoder.</strong>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>“The color is a bit off” or “the contrast of the video is a bit duller”.&nbsp; There were a staggering number of “H.264 vs Theora” encoder comparisons which came out in favor of one or the other solely based on “how well the encoder kept the color” — making the results entirely bogus.</span>
<span style="background-color: white;"><strong>2.&nbsp; Don’t compare at the same (or nearly the same) bitrate.</strong>&nbsp;I saw a VP8 vs x264 comparison the other day that gave VP8 30% more bitrate and then proceeded to demonstrate that it got better PSNR.<em>&nbsp;</em>You would think this is blindingly obvious, but people still make this mistake!&nbsp; The most common cause of this is assuming that encoders will successfully reach the target bitrate you ask of them — particularly with very broken encoders that don’t.&nbsp; Always check the output filesizes of your encodes.</span>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>The comparison lists perfectly round bitrates for every single test, as opposed to the actual bitrates achieved by the encoders, which will never be exactly matching in any real test.</span>
<span style="background-color: white;"><strong>3.&nbsp; Use unfair encoding settings.&nbsp;</strong>This is a bit of a wide topic: there are many ways to do this.&nbsp; We’ll cover the more blatant ones in this part.&nbsp; Here’s some common ones:</span>
<span style="background-color: white;"><strong>a.&nbsp; Simply cheat.</strong>&nbsp;Intentionally pick awful settings for the encoder you don’t like.</span>
<span style="background-color: white;"><strong>b.&nbsp; Don’t consider performance.</strong>&nbsp;Pick encoding settings without any regard for some particular performance goal.&nbsp; For example, it’s perfectly reasonable to say “use the best settings possible, regardless of speed”.&nbsp; It’s also reasonable to look for a particular encoding speed target.&nbsp; But what isn’t reasonable is to pick extremely fast settings for one encoder and extremely slow settings for another encoder.</span>
<span style="background-color: white;"><strong>c.&nbsp; Don’t attempt match compatibility options when it’s reasonable to do so.</strong>&nbsp;Keyframe interval is a classic one of these: shorter values reduce compression but improve seeking.&nbsp; An easy way to cheat is to simply not set them to the same value, biasing towards whatever encoder has the longer interval.&nbsp; This is most common as an accidental mistake with comparisons involving ffmpeg, where the default keyframe interval is an insanely low 12 frames.</span>
<span style="background-color: white;"><strong>How to spot it:</strong>&nbsp;The comparison doesn’t document its approach regarding choice of encoding settings.</span>
<span style="background-color: white;"><strong>4.&nbsp; Use ratecontrol methods unfairly.</strong>&nbsp;Constant bitrate is not the same as average bitrate — using one instead of the other is a great way to completely ruin a comparison.&nbsp; Another method is to use 1-pass bitrate mode for one encoder and 2-pass or constant quality for another.&nbsp; A good general approach is that, for any given encoder, one should use 2-pass if available and constant quality if not (it may take a few runs to get the bitrate you want, of course).</span>
<span style="background-color: white;">Of course, it’s also fine to run a comparison with a particular mode in mind — for example, a comparison targeted at streaming applications might want to test using 1-pass CBR.&nbsp; Of course, in such a case, if CBR is not available in an encoder, you&nbsp;<em>can’t compare to that encoder</em>.</span>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>It’s usually pretty obvious if the encoding settings are given.</span>
<span style="background-color: white;"><strong>5.&nbsp; Use incredibly old versions of encoders.</strong>&nbsp;As it happens, Debian stable is not the best source for the most recent encoding software.&nbsp; Equally, using recent versions known to be buggy.</span>
<span style="background-color: white;"><strong>6.&nbsp; Don’t distinguish between video formats and the software that encodes them.&nbsp;</strong>This is incredibly common: I’ve seen tests that claim to compare “H.264″ against something else while in fact actually comparing “Quicktime” against something else.&nbsp; It’s impossible to compare all H.264 encoders at once, so don’t even try — just call the comparison “Quicktime versus X” instead of “H.264 versus X”.&nbsp; Or better yet, use a good H.264 encoder, like x264 and don’t bother testing awful encoders to begin with.</span>
<h3 style="font-size: 1.3em; margin-top: 0px; padding-bottom: 0px;"><strong style="background-color: white;">Less-obvious cheating</strong></h3><span style="background-color: white;"><strong>1.&nbsp; Pick a bitrate that’s way too low.</strong>&nbsp;Low bitrate testing is very effective at making differences between encoders obvious, particularly if doing a visual comparison.&nbsp; But past a certain point, it becomes impossible for some encoders to keep up.&nbsp; This is usually an artifact of the video format itself — a scalability limitation.&nbsp; Practically all DCT-based formats have this kind of limitation (wavelets are mostly immune).</span>
<span style="background-color: white;">In reality, this is rarely a problem, because one could merely downscale the video to resolve the problem — lower resolutions need fewer bits.&nbsp; But people rarely do this in comparisons (it’s hard to do it fairly), so the best approach is to simply not use absurdly low bitrates.&nbsp; What is “absurdly low”?&nbsp; That’s a hard question — it ends up being a matter of using one’s best judgement.</span>
<span style="background-color: white;">This tends to be less of a problem in larger-scale tests that use many different bitrates.</span>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>At least one of the encoders being compared falls apart completely and utterly in the screenshots.</span>
<span style="background-color: white;"><strong>Biases towards, a lot:</strong>&nbsp;Video formats with completely scalable coding methods (Dirac, Snow, JPEG-2000, SVC).</span>
<span style="background-color: white;"><strong>Biases towards, a little:&nbsp;</strong>Video formats with coding methods that improve scalability, such as arithmetic coding, B-frames, and run-length coding.&nbsp; For example, H.264 and Theora tend to be more scalable than MPEG-4.</span>
<span style="background-color: white;"><strong>2.&nbsp; Pick a bitrate that’s way too high.</strong>&nbsp;This is staggeringly common mistake: pick a bitrate so high that all of the resulting encodes look absolutely perfect.&nbsp; The claim is then made that “there’s no significant difference” between any of the encoders tested.&nbsp; This is surprisingly easy to do inadvertently on sources like Big Buck Bunny, which looks transparent at relatively low bitrates.&nbsp; An equally common but similar mistake is to test at a bitrate that isn’t so high that the videos look perfect, but high enough that they all look very good.&nbsp; The claim is then made that “the difference between these encoders is small”.&nbsp; Well, of course, if you give everything tons of bitrate, the difference between encoders is small.</span>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>You can’t tell which image is the source and which is the encode.</span>
<span style="background-color: white;"><strong>3.&nbsp;&nbsp;[Making invalid comparisons using objective metrics](http://x264dev.multimedia.cx/?p=458" target="_blank).</strong>&nbsp;I explained this earlier in the linked blog post, but in short, if you’re going to measure PSNR, make sure all the encoders are optimized for PSNR.&nbsp; Equally, if you’re going to leave the encoder optimized for visual quality, don’t measure PSNR — post screenshots instead.&nbsp; Same with SSIM or any other objective metric.&nbsp; Furthermore, don’t blindly do metric comparisons — always at least&nbsp;<em>look&nbsp;</em>at the output as a sanity test.&nbsp; Finally,&nbsp;<strong>do not claim that PSNR is particularly representative of visual quality, because it isn’t.</strong></span>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>Encoders with psy optimizations, such as x264 or Theora 1.2, do considerably worse than expected in PSNR tests, but look much better in visual comparisons.</span>
<span style="background-color: white;"><strong>4.&nbsp; Lying with graphs.</strong>&nbsp;Using misleading scales on graphs is a great way to make the differences between encoders seem larger or smaller than they actually are.&nbsp; A common mistake is to scale SSIM linearly: in fact, 0.99 is about twice as good as 0.98, not 1% better.&nbsp; One solution for this is to use db to compare SSIM values.</span>
<span style="background-color: white;"><strong>5.&nbsp; Using lossy screenshots.&nbsp;</strong>Posting screenshots as JPEG is a silly, pointless way to worsen an encoder comparison.</span>
<h3 style="font-size: 1.3em; margin-top: 0px; padding-bottom: 0px;"><strong style="background-color: white;">Subtle cheating</strong></h3><span style="background-color: white;"><strong>1.&nbsp; Unfairly pick screenshots for comparison.&nbsp;</strong>Comparing based on stills is not ideal, but it’s often vastly easier than comparing videos in motion.&nbsp; But it also opens up the door to unfairness.&nbsp; One of the most common mistakes is to pick a frame immediately after (or on) a keyframe for one encoder, but which isn’t for the other encoder.&nbsp; Particularly in the case of encoders that massively boost keyframe quality, this will unfairly bias in favor of the one with the recent keyframe.</span>
<span style="background-color: white;"><strong>How to spot it:&nbsp;</strong>It’s very difficult to tell, if not impossible, unless they provide the video files to inspect.</span>
<span style="background-color: white;"><strong>2.&nbsp; Cherry-pick source videos.&nbsp;</strong>Good source videos are incredibly hard to come by — almost everything is already compressed and what’s left is usually a very poor example of real content.&nbsp; Here’s some common ways to bias unfairly using cherry-picking:</span>
<span style="background-color: white;"><strong>a.&nbsp; Pick source videos that are already heavily compressed.</strong>&nbsp;Pre-compressed source isn’t much of an issue if your target quality level for testing is much lower than that of the source, since any compression artifacts in the source will be a lot smaller than those created by the encoders.&nbsp; But if the source is already very compressed, or you’re testing at a relatively high quality level, this becomes a significant issue.</span>
<span style="background-color: white;"><strong>Biases towards:&nbsp;</strong>Anything that uses a similar transform to the source content.&nbsp; For MPEG-2 source material, this biases towards formats that use the 8x8dct or a very close approximation: MPEG-1/2/4, H.263, and Theora.&nbsp; For H.264 source material, this biases towards formats that use a 4×4 transform: H.264 and VP8.</span>
<span style="background-color: white;"><strong>b.&nbsp; Pick standard test clips that were not intended for this purpose.</strong>&nbsp;There are a wide variety of uncompressed “[standard test clips](http://media.xiph.org/video/derf/" target="_blank)“.&nbsp; Some of these are not intended for general-purpose use, but rather exist to test specific encoder capabilities.&nbsp; For example, Mobile Calendar (“mobcal”) is extremely sharp and low motion, serving to test interpolation capabilities.&nbsp; It will bias incredibly heavily towards whatever encoder uses more B-frames and/or has higher-precision motion compensation.&nbsp; Other test clips are almost completely static, such as the classic “akiyo”.&nbsp; These are also not particularly representative of real content.</span>
<span style="background-color: white;"><strong>c.&nbsp; Pick very noisy content.&nbsp;</strong>Noise is — by definition — not particularly compressible.&nbsp; Both in terms of PSNR and visual quality, a very noisy test clip will tend to reduce the differences between encoders dramatically.</span>
<span style="background-color: white;"><strong>d.&nbsp; Pick a test clip to exercise a specific encoder feature.</strong>&nbsp;I’ve often used short clips from&nbsp;[Touhou games](http://x264.nl/developers/Dark_Shikari/Flash/saextra.html" target="_blank)&nbsp;to demonstrate the effectiveness of x264′s macroblock-tree algorithm.&nbsp; I’ve sometimes even used it to compare to other encoders as part of such a demonstration.&nbsp; I’ve also used the standard test clip “parkrun” as a demonstration of adaptive quantization.&nbsp; But claiming that either is representative of most real content — and thus can be used as a general determinant of how good encoders are — is of course insane.</span>
<strong style="background-color: white;">e.&nbsp; Simply encode a bunch of videos and pick the one your favorite encoder does best on.</strong>
<span style="background-color: white;"><strong>3.&nbsp; Preprocessing the source.&nbsp;</strong>A encoder test is a test of encoders, not preprocessing.&nbsp; Some encoding apps may add preprocessors to the source, such as noise reduction.&nbsp; This may make the video look better — possibly even better than the source — but it’s not a fair part of comparing the actual encoders.</span>
<span style="background-color: white;"><strong>4.&nbsp; Screw up decoding.</strong>&nbsp;People often forget that in addition to encoding, a test also involves decoding — a step which is equally possible to do wrong.&nbsp; One common error caused by this is in tests of Theora on content whose resolution isn’t divisible by 16.&nbsp; Decoding is often done with ffmpeg — which doesn’t crop the edges properly in some cases.&nbsp; This isn’t really a big deal visually, but in a PSNR comparison, misaligning the entire frame by 4 or 8 pixels is a great way of completely invalidating the results.</span>
<h3 style="font-size: 1.3em; margin-top: 0px; padding-bottom: 0px;"><strong style="background-color: white;">The greatest mistake of all</strong></h3><blockquote class="tr_bq"><span style="background-color: white;">Above all, the biggest and most common mistake — and the one that leads to many of the problems mentioned here –&nbsp; is the mistaken belief that one, or even a few tests can really represent all usage fairly.&nbsp; Any comparison has to have some specific goal — to compare something in some particular case, whether it be “maximum offline compression ignoring encoding speed” or “real-time high-speed video streaming” or whatnot.&nbsp; And even then, no comparison can represent all use-cases in that category alone.&nbsp; An encoder comparison can only be honest if it’s aware of its limitations.</span></blockquote></div></div>

</div>
  <footer class="post-footer">
    <nav class="paginav">
      <a class="prev" href="https://serge-m.github.io/posts/fast-way-of-copying-byte-array-in-cc/">
        <span class="title">« Prev Page</span>
        <br>
        <span>Fast way of copying byte array in C/C&#43;&#43; (With measurements)</span>
      </a>
      <a class="next" href="https://serge-m.github.io/posts/using-h264multiview-codec-from-intel/">
        <span class="title">Next Page »</span>
        <br>
        <span>Using h264/multiview codec from Intel Media SDK</span>
      </a>
    </nav><div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to cheat on video encoder comparisons on twitter"
        href="https://twitter.com/intent/tweet/?text=How%20to%20cheat%20on%20video%20encoder%20comparisons&amp;url=https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f&amp;hashtags=">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to cheat on video encoder comparisons on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f&amp;title=How%20to%20cheat%20on%20video%20encoder%20comparisons&amp;summary=How%20to%20cheat%20on%20video%20encoder%20comparisons&amp;source=https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to cheat on video encoder comparisons on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f&title=How%20to%20cheat%20on%20video%20encoder%20comparisons">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to cheat on video encoder comparisons on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to cheat on video encoder comparisons on whatsapp"
        href="https://api.whatsapp.com/send?text=How%20to%20cheat%20on%20video%20encoder%20comparisons%20-%20https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share How to cheat on video encoder comparisons on telegram"
        href="https://telegram.me/share/url?text=How%20to%20cheat%20on%20video%20encoder%20comparisons&amp;url=https%3a%2f%2fserge-m.github.io%2fposts%2fhow-to-cheat-on-video-encoder%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://serge-m.github.io/">sergem&#39;s personal public notebook</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>
<script defer src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>

<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
</body>

</html>
