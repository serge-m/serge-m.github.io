<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>Things about C++ | sergem's personal public notebook</title><meta name=keywords content="c++"><meta name=description content="rules for resolving calls to overloaded functions:&nbsp;- identify the function that's the best match for the call (name, parameters etc)checks accessibility for the best-match function. Resolving function overloads (my) ![](http://4.bp.blogspot.com/-QLJfqdOD7GI/UuKOhiNr9CI/AAAAAAAAAbo/zxi4-98NBwY/s1600/functionsOverloadingSchemeCPP.png) Resolving function overloadssrc:[http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm](http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm&#34; target=&#34;_blank) The compiler works through the following checklist and if it still can't reach a decision, it issues an error:Gather all the functions in the current scope that have the same name as the function called.Exclude those that don't have the right number of parameters to match the arguments in the call."><meta name=author content="SergeM"><link rel=canonical href=https://serge-m.github.io/posts/things-about-c/><link href=/assets/css/stylesheet.min.6d98a2276d0cb41ef459267b3ff3ef02df70a8f16b70bbc52b20568702bc90cf.css integrity="sha256-bZiiJ20MtB70WSZ7P/PvAt9wqPFrcLvFKyBWhwK8kM8=" rel="preload stylesheet" as=style><link rel=icon href=https://serge-m.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://serge-m.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://serge-m.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://serge-m.github.io/apple-touch-icon.png><link rel=mask-icon href=https://serge-m.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><meta name=generator content="Hugo 0.101.0"><script type=application/javascript>var doNotTrack=!1;doNotTrack||(function(e,t,n,s,o,i,a){e.GoogleAnalyticsObject=o,e[o]=e[o]||function(){(e[o].q=e[o].q||[]).push(arguments)},e[o].l=1*new Date,i=t.createElement(n),a=t.getElementsByTagName(n)[0],i.async=1,i.src=s,a.parentNode.insertBefore(i,a)}(window,document,"script","https://www.google-analytics.com/analytics.js","ga"),ga("create","UA-40853494-2","auto"),ga("send","pageview"))</script><meta property="og:title" content="Things about C++"><meta property="og:description" content="rules for resolving calls to overloaded functions:&nbsp;- identify the function that's the best match for the call (name, parameters etc)checks accessibility for the best-match function. Resolving function overloads (my) ![](http://4.bp.blogspot.com/-QLJfqdOD7GI/UuKOhiNr9CI/AAAAAAAAAbo/zxi4-98NBwY/s1600/functionsOverloadingSchemeCPP.png) Resolving function overloadssrc:[http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm](http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm&#34; target=&#34;_blank) The compiler works through the following checklist and if it still can't reach a decision, it issues an error:Gather all the functions in the current scope that have the same name as the function called.Exclude those that don't have the right number of parameters to match the arguments in the call."><meta property="og:type" content="article"><meta property="og:url" content="https://serge-m.github.io/posts/things-about-c/"><meta property="og:image" content="https://serge-m.github.io/papermod-cover.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2014-01-06T13:28:00+00:00"><meta property="article:modified_time" content="2014-01-06T13:28:00+00:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://serge-m.github.io/papermod-cover.png"><meta name=twitter:title content="Things about C++"><meta name=twitter:description content="rules for resolving calls to overloaded functions:&nbsp;- identify the function that's the best match for the call (name, parameters etc)checks accessibility for the best-match function. Resolving function overloads (my) ![](http://4.bp.blogspot.com/-QLJfqdOD7GI/UuKOhiNr9CI/AAAAAAAAAbo/zxi4-98NBwY/s1600/functionsOverloadingSchemeCPP.png) Resolving function overloadssrc:[http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm](http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm&#34; target=&#34;_blank) The compiler works through the following checklist and if it still can't reach a decision, it issues an error:Gather all the functions in the current scope that have the same name as the function called.Exclude those that don't have the right number of parameters to match the arguments in the call."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Posts","item":"https://serge-m.github.io/posts/"},{"@type":"ListItem","position":2,"name":"Things about C++","item":"https://serge-m.github.io/posts/things-about-c/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"Things about C++","name":"Things about C\u002b\u002b","description":"rules for resolving calls to overloaded functions:\u0026nbsp;- identify the function that's the best match for the call (name, parameters etc)checks accessibility for the best-match function. Resolving function overloads (my) ![](http://4.bp.blogspot.com/-QLJfqdOD7GI/UuKOhiNr9CI/AAAAAAAAAbo/zxi4-98NBwY/s1600/functionsOverloadingSchemeCPP.png) Resolving function overloadssrc:[http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm](http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm\" target=\"_blank) The compiler works through the following checklist and if it still can't reach a decision, it issues an error:Gather all the functions in the current scope that have the same name as the function called.Exclude those that don't have the right number of parameters to match the arguments in the call.","keywords":["c++"],"articleBody":"rules for resolving calls to overloaded functions: - identify the function that's the best match for the call (name, parameters etc)checks accessibility for the best-match function. Resolving function overloads (my) ![](http://4.bp.blogspot.com/-QLJfqdOD7GI/UuKOhiNr9CI/AAAAAAAAAbo/zxi4-98NBwY/s1600/functionsOverloadingSchemeCPP.png) Resolving function overloadssrc:[http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm](http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm\" target=\"_blank) The compiler works through the following checklist and if it still can't reach a decision, it issues an error:Gather all the functions in the current scope that have the same name as the function called.Exclude those that don't have the right number of parameters to match the arguments in the call. (It has to be careful about parameters with default values; void f(int x, int y = 0) is a candidate for the call f(25);)If no function matches, the compiler reports an error.If there is more than one match, select the 'best match'.If there is no clear winner of the best matches, the compiler reports an error - ambiguous function call.Best matchingIn deciding on the best match, the compiler works on a rating system for the way the types passed in the call and the competing parameter lists match up. In decreasing order of goodness of match:An exact match, e.g. argument is a double and parameter is a doubleA promotionA standard type conversionA constructor or user-defined type conversionExact matchesAn exact match is where the parameter and argument datatypes match exactly. Note that, for the purposes of overload resolution a pointer to an array of type x exactly matches a pointer of type x. This is because arrays are always passed by reference, meaning that you actually pass a pointer to the first element of the array. For example:void f(int y[ ]); // call this f1 void f(int* z); // call this f2 .... int x[ ] = {1, 2, 3, 4}; f(x); // Both f1 and f2 are exact matches, so the call is ambiguous. void sf(const char s[]); void sf(const char*); …. sf(“abc”); // Same problem; both sf functions are exact matches. Type promotionThe following are described as “promotions”:A char, unsigned char or short can be promoted to an int. For example void f(int); can be a match for f(‘a’);A float can be promoted to a double.A bool can be promoted to an int (FALSE counts as 0, TRUE as 1).Standard conversionsAll the following are described as “standard conversions”:conversions between integral types, apart from the ones counted as promotions. Remember that bool and char are integral types as well as int, short and long.conversions between floating types: double, float and long double, except for float to double which counts as a promotion.conversions between floating and integral typesconversions of integral, floating and pointer types to bool (zero or NULL is FALSE, anything else is TRUE)conversion of an integer zero to the NULL pointer.All of the standard conversions are treated as equivalent for scoring purposes. A seemingly minor standard conversion, such as int to long, does not count as any “better” than a more drastic one such as double to bool.Constructors and user-defined conversionsA certain kind of constructor can play a special role in type conversion. Suppose you had a class Bigint that was capable of storing integral numbers larger than INT_MAX, and you had a constructor for a Bigint that took a C-string, so that a declaration of a Bigint object might look like this:Bigint b(“12345678901234567890”); This constructor also provides an implicit type conversion. Having defined b as a Bigint, it would be possible to say, for example:b = “999999999999”; or you could invoke the type-conversion explicitly:\nb = static_cast(\"88888888888\"); The same type-conversion would be used in parameter passing, enabling us to do this:void f(Bigint); f(“77777777777777”); We are able to pass a C-string to a function that expects a Bigint because there exists a Bigint constructor that takes a C-string.\nThis kind of conversion can only work when the constructor can be called with just one argument. Generally this means that the constructor will have just one parameter, but it could have more if all but the first of the parameters (or, indeed, all of them) had default values.When you think about using this type-conversion in assignment, it is obvious that the constructor must be of the kind that can be called with only one argument. In the statement:b = something; the \"something\" can't be nothing, and it can't be more than one thing. In the context of parameter passing, the compiler has to be able to find a parameter for each argument. It would not consider void f(Bigint) as a candidate for f(\"6666666\", 57); even if the Bigint class had a constructor that took a C-string and an int - the compiler needs one parameter for the \"6666666\" and another for the 57.The compiler also has to find an argument for each parameter that is not given an explicit default in the function header, so it would not consider void f(Bigint) as a candidate for f(); even if Bigint had a constructor with no parameters or a constructor with all its parameters defaulted. (It would, however, consider void f(Bigint b = \"0\") as a candidate for f(); since the parameter of the function f (as opposed to the parameter of the Bigint constructor) has an explicit default.)These \"conversion constructors\" enable us to have object parameters corresponding to arguments of other types.User-defined conversions are for going the other way. They enable us to pass objects (as arguments) to functions with parameters of other types, as in the following:void f(int n); Bigint b(“123456”); f(b); // would work if there was a Bigint::operator int() conversion function Conversion member-functions allow you to specify how you want objects to respond if they are asked to behave as if they were objects of some other type. In this case, a Bigint is being treated as if it were an int. A conversion function that allowed the above code to work might take the form:class Bigint { public: … operator int(); // returns a Bigint as an int. … // Note there is no return type and no parameter list. };\nBigint::operator int() { If the value of the Bigint is less than INT_MAX, return the value as an int, else return -1; // or throw an exception or something }explicitIt can happen that you have a constructor that can be called with just one argument, and which will therefore behave as a conversion constructor, but you don’t want it to behave in this way. Perhaps we have a Bigint constructor that takes a string. This would mean that you could write something like:Bigint b; b = “987654321”; But implicit type-conversions are a common source of programming error, so you might decide to disallow that sort of conversion. We can do that simply by inserting the keyword explicit before the constructor prototype in the class definition:\nclass Bigint { public: ...... explicit Bigint(string); ...... }; With that explicit before the constructor, we cannot now make use of implicit type-conversion from C-string to Bigint: void proc(Bigint); Bigint b; b = \"99999999999\"; // Error! Implicit type conversion not allowed proc(\"9999999999999\"); // not allowed b = static_cast(\"999999999999\"); // OK, type conversion explicit proc(Bigint(\"999999999999\")); // OK A note on const ref parametersSuppose that the Bigint class had a constructor that took an int. It would then be possible to pass an int to a function that expected a Bigint:void proc(Bigint bx) { …… }\nproc(54321); The parameter here was a value parameter. Would it have made any difference if the parameter had been a const ref, i.e.\nvoid proc(const Bigint\u0026 bx) { ...... } proc(54321); At first sight, this looks rather strange. When you pass an argument by reference, the parameter name becomes an alternative to the argument name - two names for the same thing. But here, we are not passing anything that has a name; we are simply passing a value. To put it more technically, the argument has an r-value but not an l-value (you could use it on the right-hand side of an assignment but not on the left-hand side). There is, apparently, nothing for bx to refer to.But in fact it would work. When you pass an argument that has an l-value to a const ref parameter, you get the ordinary call-by-reference (except, obviously, that the parameter is const). When you pass an argument that has only an r-value, a temporary variable is created with the same type as the parameter, and the const ref parameter refers to this temporary variable. So, in this example, a temporary variable of type Bigint is created, the value 54321 is used to initialise it, and this is the object to which bx refers. The temporary variable disappears when proc terminates. (In other words, when the argument has no l-value, the const ref parameter behaves very like a value parameter.)Parameter lists that include default valuesParameters with default values carry their full weight in the scoring of a function. For example:void f (int x, double y, int z = 2); // (f1) void f (int x, int y); // (f2) … f(3, 4.5); // matches f1 exactly, whereas f2 requires a double-to-int standard conversion Choosing a winnerA candidate function is only as strong as its weakest match; a candidate requiring three promotions, for example, beats a candidate with two exact matches and a standard conversion. Candidates whose weakest matches are equivalently weak are compared on their next-weakest, and so on - a candidate with a standard conversion, a promotion and an exact match beats a candidate with a standard conversion and two promotions.\n","wordCount":"1547","inLanguage":"en","datePublished":"2014-01-06T13:28:00Z","dateModified":"2014-01-06T13:28:00Z","author":{"@type":"Person","name":"SergeM"},"mainEntityOfPage":{"@type":"WebPage","@id":"https://serge-m.github.io/posts/things-about-c/"},"publisher":{"@type":"Organization","name":"sergem's personal public notebook","logo":{"@type":"ImageObject","url":"https://serge-m.github.io/favicon.ico"}}}</script></head><body id=top><script>window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><noscript><style type=text/css>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:#1d1e20;--entry:#2e2e33;--primary:rgba(255, 255, 255, 0.84);--secondary:rgba(255, 255, 255, 0.56);--tertiary:rgba(255, 255, 255, 0.16);--content:rgba(255, 255, 255, 0.74);--hljs-bg:#2e2e33;--code-bg:#37383e;--border:#333}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><header class=header><nav class=nav><div class=logo><a href=https://serge-m.github.io/ accesskey=h title="Home (Alt + H)">Home</a>
<span class=logo-switches></span></div><ul id=menu onscroll=menu_on_scroll()><li><a href=https://serge-m.github.io/archives title=Archive><span>Archive</span></a></li><li><a href=https://serge-m.github.io/categories/ title=Categories><span>Categories</span></a></li><li><a href=https://serge-m.github.io/search/ title="Search (Alt + /)" accesskey=/><span>Search</span></a></li><li><a href=https://serge-m.github.io/tags/ title=Tags><span>Tags</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><div class=breadcrumbs><a href=https://serge-m.github.io/>Home</a>&nbsp;»&nbsp;<a href=https://serge-m.github.io/posts/>Posts</a></div><h1 class=post-title>Things about C++</h1><div class=post-meta>January 6, 2014&nbsp;·&nbsp;SergeM</div></header><div class=toc><details><summary accesskey=c title="(Alt + C)"><div class=details>Table of Contents</div></summary><div class=inner><ul><li><a href=# aria-label="Resolving function overloads (my)">Resolving function overloads (my)</a></li><li><a href=# aria-label="Resolving function overloads">Resolving function overloads</a><ul><li><a href=# aria-label="Best matching">Best matching</a></li><li><a href=# aria-label="Exact matches">Exact matches</a></li><li><a href=# aria-label="Type promotion">Type promotion</a></li><li><a href=# aria-label="Standard conversions">Standard conversions</a></li><li><a href=# aria-label="Constructors and user-defined conversions">Constructors and user-defined conversions</a></li><li><a href=# aria-label=explicit>explicit</a></li><li><a href=# aria-label="A note on const ref parameters">A note on const ref parameters</a></li><li><a href=# aria-label="Parameter lists that include default values">Parameter lists that include default values</a></li><li><a href=# aria-label="Choosing a winner">Choosing a winner</a></li></ul></li></ul></div></details></div><div class=post-content><ol style=text-align:left><li>rules for resolving calls to overloaded functions:&nbsp;</li>-<li>identify the function that's the best match for the call (name, parameters etc)</li><li>checks accessibility for the best-match function.</li></ol><div></div><div><h2 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:15pt>Resolving function overloads (my)</h2></div><div></div>![](http://4.bp.blogspot.com/-QLJfqdOD7GI/UuKOhiNr9CI/AAAAAAAAAbo/zxi4-98NBwY/s1600/functionsOverloadingSchemeCPP.png)<div></div><div><h2 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:15pt>Resolving function overloads</h2></div><div>src:[http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm](http://www.dcs.bbk.ac.uk/~roger/cpp/week20.htm" target="_blank)</div><div></div><div><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>The compiler works through the following checklist and if it still can't reach a decision, it issues an error:</div><ol style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px><li>Gather all the functions in the current scope that have the same name as the function called.</li><li>Exclude those that don't have the right number of parameters to match the arguments in the call. (It has to be careful about parameters with default values;&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">void f(int x, int y = 0)</code>&nbsp;is a candidate for the call&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">f(25);</code>)</li><li>If no function matches, the compiler reports an error.</li><li>If there is more than one match, select the 'best match'.</li><li>If there is no clear winner of the best matches, the compiler reports an error - ambiguous function call.</li></ol><div><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt;text-align:left>Best matching</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>In deciding on the best match, the compiler works on a rating system for the way the types passed in the call and the competing parameter lists match up. In decreasing order of goodness of match:</div><ol style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px><li>An exact match, e.g. argument is a double and parameter is a double</li><li>A promotion</li><li>A standard type conversion</li><li>A constructor or user-defined type conversion</li></ol><div><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>Exact matches</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>An exact match is where the parameter and argument datatypes match exactly. Note that, for the purposes of overload resolution a pointer to an array of type x exactly matches a pointer of type x. This is because arrays are always passed by reference, meaning that you actually pass a pointer to the first element of the array. For example:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void f(int y[ ]);    // call this f1
void f(int* z);      // call this f2
....
int x[ ] = {1, 2, 3, 4};
f(x);         // Both f1 and f2 are exact matches, so the call is ambiguous.
<p>void sf(const char s[]);
void sf(const char*);
&hellip;.
sf(&ldquo;abc&rdquo;);   // Same problem; both sf functions are exact matches.
</pre><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>Type promotion</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>The following are described as &ldquo;promotions&rdquo;:</div><ul style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px><li>A <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">char</code>, <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">unsigned</code> <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">char</code> or <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">short</code> can be promoted to an <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">int</code>. For example <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">void f(int);</code> can be a match for <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">f(&lsquo;a&rsquo;);</code></li><li>A <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">float</code> can be promoted to a <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">double</code>.</li><li>A <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">bool</code> can be promoted to an <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">int</code> (FALSE counts as 0, TRUE as 1).</li></ul><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>Standard conversions</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>All the following are described as &ldquo;standard conversions&rdquo;:</div><ul style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px><li>conversions between integral types, apart from the ones counted as promotions. Remember that <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">bool</code> and <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">char</code> are integral types as well as <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">int</code>, <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">short</code> and <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">long</code>.</li><li>conversions between floating types: <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">double</code>, <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">float</code> and <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">long double</code>, except for <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">float</code> to <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">double</code> which counts as a promotion.</li><li>conversions between floating and integral types</li><li>conversions of integral, floating and pointer types to <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">bool</code> (zero or NULL is FALSE, anything else is TRUE)</li><li>conversion of an integer zero to the <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">NULL</code> pointer.</li></ul><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>All of the standard conversions are treated as equivalent for scoring purposes. A seemingly minor standard conversion, such as <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">int</code> to <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">long</code>, does not count as any &ldquo;better&rdquo; than a more drastic one such as <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">double</code> to <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">bool</code>.</div><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>Constructors and user-defined conversions</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>A certain kind of constructor can play a special role in type conversion. Suppose you had a class <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">Bigint</code> that was capable of storing integral numbers larger than INT_MAX, and you had a constructor for a <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">Bigint</code> that took a C-string, so that a declaration of a <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">Bigint</code> object might look like this:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">Bigint b(&ldquo;12345678901234567890&rdquo;);
</pre><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>This constructor also provides an implicit type conversion. Having defined <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">b</code> as a <code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">Bigint</code>, it would be possible to say, for example:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">b = &ldquo;999999999999&rdquo;;
</pre><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>or you could invoke the type-conversion explicitly:</span></p><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">b = static_cast<bigint>("88888888888");
</pre><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>The same type-conversion would be used in parameter passing, enabling us to do this:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void f(Bigint);
<p>f(&ldquo;77777777777777&rdquo;);
</pre><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>We are able to pass a C-string to a function that expects a Bigint because there exists a Bigint constructor that takes a C-string.</span></p><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>This kind of conversion can only work when the constructor can be called with just one argument. Generally this means that the constructor will have just one parameter, but it could have more if all but the first of the parameters (or, indeed, all of them) had default values.</div><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>When you think about using this type-conversion in assignment, it is obvious that the constructor must be of the kind that can be called with only one argument. In the statement:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">b = something;
</pre><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>the "something" can't be nothing, and it can't be more than one thing.</span><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>In the context of parameter passing, the compiler has to be able to find a parameter for each argument. It would not consider&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">void f(Bigint)</code>&nbsp;as a candidate for&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">f("6666666", 57);</code>&nbsp;even if the Bigint class had a constructor that took a C-string and an int - the compiler needs one parameter for the "6666666" and another for the 57.</div><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>The compiler also has to find an argument for each parameter that is not given an explicit default in the function header, so it would not consider&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">void f(Bigint)</code>&nbsp;as a candidate for&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">f();</code>&nbsp;even if Bigint had a constructor with no parameters or a constructor with all its parameters defaulted. (It would, however, consider&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">void f(Bigint b = "0")</code>&nbsp;as a candidate for&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">f();</code>&nbsp;since the parameter of the function&nbsp;<code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:10pt;line-height:10pt">f</code>&nbsp;(as opposed to the parameter of the Bigint constructor) has an explicit default.)</div><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>These "conversion constructors" enable us to have object parameters corresponding to arguments of other types.</div><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px><strong>User-defined conversions</strong>&nbsp;are for going the other way. They enable us to pass objects (as arguments) to functions with parameters of other types, as in the following:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void f(int n);
<p>Bigint b(&ldquo;123456&rdquo;);
f(b);                // would work if there was a Bigint::operator int() conversion function
</pre><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>Conversion member-functions allow you to specify how you want objects to respond if they are asked to behave as if they were objects of some other type. In this case, a Bigint is being treated as if it were an int. A conversion function that allowed the above code to work might take the form:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">class Bigint
{ public:
&hellip;
operator int();    // returns a Bigint as an int.
&hellip;                // Note there is no return type and no parameter list.
};</p>
<p>Bigint::operator int()
{  If the value of the Bigint is less than INT_MAX,
return the value as an int,
else return -1;   // or throw an exception or something
}</pre><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>explicit</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>It can happen that you have a constructor that can be called with just one argument, and which will therefore behave as a conversion constructor, but you don&rsquo;t want it to behave in this way. Perhaps we have a Bigint constructor that takes a string. This would mean that you could write something like:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">Bigint b;
b = &ldquo;987654321&rdquo;;
</pre><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>But implicit type-conversions are a common source of programming error, so you might decide to disallow that sort of conversion. We can do that simply by inserting the keyword </span><code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:13px;line-height:10pt">explicit</code><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px> before the constructor prototype in the class definition:</span></p><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">class Bigint
{ public:
 ......
 explicit Bigint(string);
 ......
};
</pre><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>With that&nbsp;</span><code style="color:#909;font-family:lucida console,Courier,courier new,monospace;font-size:13px;line-height:10pt">explicit</code><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>&nbsp;before the constructor, we cannot now make use of implicit type-conversion from C-string to Bigint:</span><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void proc(Bigint);
Bigint b;
b = "99999999999";  // Error! Implicit type conversion not allowed
proc("9999999999999");  // not allowed
b = static_cast<bigint>("999999999999");  // OK, type conversion explicit
proc(Bigint("999999999999"));  // OK
</pre><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>A note on const ref parameters</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>Suppose that the Bigint class had a constructor that took an int. It would then be possible to pass an int to a function that expected a Bigint:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void proc(Bigint bx)
<p>{ &hellip;&hellip; }</p>
<p>proc(54321);
</pre><span style=background-color:#ffc;font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>The parameter here was a value parameter. Would it have made any difference if the parameter had been a const ref, i.e.</span></p><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void proc(const Bigint&amp; bx)
{ ...... }

proc(54321);
</pre><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>At first sight, this looks rather strange. When you pass an argument by reference, the parameter name becomes an alternative to the argument name - two names for the same thing. But here, we are not passing anything that has a name; we are simply passing a value. To put it more technically, the argument has an r-value but not an l-value (you could use it on the right-hand side of an assignment but not on the left-hand side). There is, apparently, nothing for bx to refer to.</div><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>But in fact it would work. When you pass an argument that has an l-value to a const ref parameter, you get the ordinary call-by-reference (except, obviously, that the parameter is const). When you pass an argument that has only an r-value, a temporary variable is created with the same type as the parameter, and the const ref parameter refers to this temporary variable. So, in this example, a temporary variable of type Bigint is created, the value 54321 is used to initialise it, and this is the object to which bx refers. The temporary variable disappears when proc terminates. (In other words, when the argument has no l-value, the const ref parameter behaves very like a value parameter.)</div><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>Parameter lists that include default values</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>Parameters with default values carry their full weight in the scoring of a function. For example:</div><pre style="background-color:#fc9;border:2px #ffc;font-family:lucida console,Courier,courier new,monospace;font-size:9pt;line-height:9pt;padding:3px;width:1889px">void f (int x, double y, int z = 2);   // (f1)
<p>void f (int x, int y);                 // (f2)
&hellip;
f(3, 4.5); // matches f1 exactly, whereas f2 requires a double-to-int standard conversion
</pre><h3 style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13pt>Choosing a winner</h3><div style=font-family:Tahoma,Verdana,Arial,Helvetica,sans-serif;font-size:13px>A candidate function is only as strong as its weakest match; a candidate requiring three promotions, for example, beats a candidate with two exact matches and a standard conversion. Candidates whose weakest matches are equivalently weak are compared on their next-weakest, and so on - a candidate with a standard conversion, a promotion and an exact match beats a candidate with a standard conversion and two promotions.</div></div></div></div><div></p></div></div><footer class=post-footer><ul class=post-tags><li><a href=https://serge-m.github.io/tags/c++/>c++</a></li></ul><nav class=paginav><a class=prev href=https://serge-m.github.io/posts/migrating-from-svn-to-git/><span class=title>« Prev Page</span><br><span>Migrating from SVN to Git and Mercurial</span></a>
<a class=next href=https://serge-m.github.io/posts/private-inheritance/><span class=title>Next Page »</span><br><span>Private inheritance</span></a></nav><div class=share-buttons><a target=_blank rel="noopener noreferrer" aria-label="share Things about C++ on twitter" href="https://twitter.com/intent/tweet/?text=Things%20about%20C%2b%2b&url=https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f&hashtags=c%2b%2b"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM195.519 424.544c135.939.0 210.268-112.643 210.268-210.268.0-3.218.0-6.437-.153-9.502 14.406-10.421 26.973-23.448 36.935-38.314-13.18 5.824-27.433 9.809-42.452 11.648 15.326-9.196 26.973-23.602 32.49-40.92-14.252 8.429-30.038 14.56-46.896 17.931-13.487-14.406-32.644-23.295-53.946-23.295-40.767.0-73.87 33.104-73.87 73.87.0 5.824.613 11.494 1.992 16.858-61.456-3.065-115.862-32.49-152.337-77.241-6.284 10.881-9.962 23.601-9.962 37.088.0 25.594 13.027 48.276 32.95 61.456-12.107-.307-23.448-3.678-33.41-9.196v.92c0 35.862 25.441 65.594 59.311 72.49-6.13 1.686-12.72 2.606-19.464 2.606-4.751.0-9.348-.46-13.946-1.38 9.349 29.426 36.628 50.728 68.965 51.341-25.287 19.771-57.164 31.571-91.8 31.571-5.977.0-11.801-.306-17.625-1.073 32.337 21.15 71.264 33.41 112.95 33.41z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things about C++ on linkedin" href="https://www.linkedin.com/shareArticle?mini=true&url=https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f&title=Things%20about%20C%2b%2b&summary=Things%20about%20C%2b%2b&source=https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM160.461 423.278V197.561h-75.04v225.717h75.04zm270.539.0V293.839c0-69.333-37.018-101.586-86.381-101.586-39.804.0-57.634 21.891-67.617 37.266v-31.958h-75.021c.995 21.181.0 225.717.0 225.717h75.02V297.222c0-6.748.486-13.492 2.474-18.315 5.414-13.475 17.767-27.434 38.494-27.434 27.135.0 38.007 20.707 38.007 51.037v120.768H431zM123.448 88.722C97.774 88.722 81 105.601 81 127.724c0 21.658 16.264 39.002 41.455 39.002h.484c26.165.0 42.452-17.344 42.452-39.002-.485-22.092-16.241-38.954-41.943-39.002z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things about C++ on reddit" href="https://reddit.com/submit?url=https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f&title=Things%20about%20C%2b%2b"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zM446 265.638c0-22.964-18.616-41.58-41.58-41.58-11.211.0-21.361 4.457-28.841 11.666-28.424-20.508-67.586-33.757-111.204-35.278l18.941-89.121 61.884 13.157c.756 15.734 13.642 28.29 29.56 28.29 16.407.0 29.706-13.299 29.706-29.701.0-16.403-13.299-29.702-29.706-29.702-11.666.0-21.657 6.792-26.515 16.578l-69.105-14.69c-1.922-.418-3.939-.042-5.585 1.036-1.658 1.073-2.811 2.761-3.224 4.686l-21.152 99.438c-44.258 1.228-84.046 14.494-112.837 35.232-7.468-7.164-17.589-11.591-28.757-11.591-22.965.0-41.585 18.616-41.585 41.58.0 16.896 10.095 31.41 24.568 37.918-.639 4.135-.99 8.328-.99 12.576.0 63.977 74.469 115.836 166.33 115.836s166.334-51.859 166.334-115.836c0-4.218-.347-8.387-.977-12.493 14.564-6.47 24.735-21.034 24.735-38.001zM326.526 373.831c-20.27 20.241-59.115 21.816-70.534 21.816-11.428.0-50.277-1.575-70.522-21.82-3.007-3.008-3.007-7.882.0-10.889 3.003-2.999 7.882-3.003 10.885.0 12.777 12.781 40.11 17.317 59.637 17.317 19.522.0 46.86-4.536 59.657-17.321 3.016-2.999 7.886-2.995 10.885.008 3.008 3.011 3.003 7.882-.008 10.889zm-5.23-48.781c-16.373.0-29.701-13.324-29.701-29.698.0-16.381 13.328-29.714 29.701-29.714 16.378.0 29.706 13.333 29.706 29.714.0 16.374-13.328 29.698-29.706 29.698zM160.91 295.348c0-16.381 13.328-29.71 29.714-29.71 16.369.0 29.689 13.329 29.689 29.71.0 16.373-13.32 29.693-29.689 29.693-16.386.0-29.714-13.32-29.714-29.693z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things about C++ on facebook" href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H342.978V319.085h66.6l12.672-82.621h-79.272v-53.617c0-22.603 11.073-44.636 46.58-44.636H425.6v-70.34s-32.71-5.582-63.982-5.582c-65.288.0-107.96 39.569-107.96 111.204v62.971h-72.573v82.621h72.573V512h-191.104c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things about C++ on whatsapp" href="https://api.whatsapp.com/send?text=Things%20about%20C%2b%2b%20-%20https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f"><svg viewBox="0 0 512 512"><path d="M449.446.0C483.971.0 512 28.03 512 62.554v386.892C512 483.97 483.97 512 449.446 512H62.554c-34.524.0-62.554-28.03-62.554-62.554V62.554c0-34.524 28.029-62.554 62.554-62.554h386.892zm-58.673 127.703c-33.842-33.881-78.847-52.548-126.798-52.568-98.799.0-179.21 80.405-179.249 179.234-.013 31.593 8.241 62.428 23.927 89.612l-25.429 92.884 95.021-24.925c26.181 14.28 55.659 21.807 85.658 21.816h.074c98.789.0 179.206-80.413 179.247-179.243.018-47.895-18.61-92.93-52.451-126.81zM263.976 403.485h-.06c-26.734-.01-52.954-7.193-75.828-20.767l-5.441-3.229-56.386 14.792 15.05-54.977-3.542-5.637c-14.913-23.72-22.791-51.136-22.779-79.287.033-82.142 66.867-148.971 149.046-148.971 39.793.014 77.199 15.531 105.329 43.692 28.128 28.16 43.609 65.592 43.594 105.4-.034 82.149-66.866 148.983-148.983 148.984zm81.721-111.581c-4.479-2.242-26.499-13.075-30.604-14.571-4.105-1.495-7.091-2.241-10.077 2.241-2.986 4.483-11.569 14.572-14.182 17.562-2.612 2.988-5.225 3.364-9.703 1.12-4.479-2.241-18.91-6.97-36.017-22.23C231.8 264.15 222.81 249.484 220.198 245s-.279-6.908 1.963-9.14c2.016-2.007 4.48-5.232 6.719-7.847 2.24-2.615 2.986-4.484 4.479-7.472 1.493-2.99.747-5.604-.374-7.846-1.119-2.241-10.077-24.288-13.809-33.256-3.635-8.733-7.327-7.55-10.077-7.688-2.609-.13-5.598-.158-8.583-.158-2.986.0-7.839 1.121-11.944 5.604-4.105 4.484-15.675 15.32-15.675 37.364.0 22.046 16.048 43.342 18.287 46.332 2.24 2.99 31.582 48.227 76.511 67.627 10.685 4.615 19.028 7.371 25.533 9.434 10.728 3.41 20.492 2.929 28.209 1.775 8.605-1.285 26.499-10.833 30.231-21.295 3.732-10.464 3.732-19.431 2.612-21.298-1.119-1.869-4.105-2.99-8.583-5.232z"/></svg></a><a target=_blank rel="noopener noreferrer" aria-label="share Things about C++ on telegram" href="https://telegram.me/share/url?text=Things%20about%20C%2b%2b&url=https%3a%2f%2fserge-m.github.io%2fposts%2fthings-about-c%2f"><svg viewBox="2 2 28 28"><path d="M26.49 29.86H5.5a3.37 3.37.0 01-2.47-1 3.35 3.35.0 01-1-2.47V5.48A3.36 3.36.0 013 3 3.37 3.37.0 015.5 2h21A3.38 3.38.0 0129 3a3.36 3.36.0 011 2.46V26.37a3.35 3.35.0 01-1 2.47 3.38 3.38.0 01-2.51 1.02zm-5.38-6.71a.79.79.0 00.85-.66L24.73 9.24a.55.55.0 00-.18-.46.62.62.0 00-.41-.17q-.08.0-16.53 6.11a.59.59.0 00-.41.59.57.57.0 00.43.52l4 1.24 1.61 4.83a.62.62.0 00.63.43.56.56.0 00.4-.17L16.54 20l4.09 3A.9.9.0 0021.11 23.15zM13.8 20.71l-1.21-4q8.72-5.55 8.78-5.55c.15.0.23.0.23.16a.18.18.0 010 .06s-2.51 2.3-7.52 6.8z"/></svg></a></div></footer></article></main><footer class=footer><span>&copy; 2022 <a href=https://serge-m.github.io/>sergem's personal public notebook</a></span>
<span>&#183;</span>
<span>Powered by <a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a></span>
<span>&#183;</span>
<span>Theme <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)"><button class=top-link id=top-link type=button accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></button></a>
<script defer src=/assets/js/highlight.min.e85ad0406048e8176e1c7661b25d5c69297ddfe41dc4124cf75ecb99a4f7b3d1.js integrity="sha256-6FrQQGBI6BduHHZhsl1caSl93+QdxBJM917LmaT3s9E=" onload=hljs.initHighlightingOnLoad()></script>
<script>window.onload=function(){localStorage.getItem("menu-scroll-position")&&(document.getElementById("menu").scrollLeft=localStorage.getItem("menu-scroll-position"))};function menu_on_scroll(){localStorage.setItem("menu-scroll-position",document.getElementById("menu").scrollLeft)}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script></body></html>