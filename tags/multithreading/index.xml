<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>multithreading on sergem&#39;s personal public notebook</title>
    <link>https://serge-m.github.io/tags/multithreading/</link>
    <description>Recent content in multithreading on sergem&#39;s personal public notebook</description>
    <image>
      <url>https://serge-m.github.io/papermod-cover.png</url>
      <link>https://serge-m.github.io/papermod-cover.png</link>
    </image>
    <generator>Hugo -- gohugo.io</generator>
    <lastBuildDate>Tue, 19 May 2015 17:46:00 +0000</lastBuildDate><atom:link href="https://serge-m.github.io/tags/multithreading/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Double checked lock (DCL)</title>
      <link>https://serge-m.github.io/posts/double-checked-lock-dcl/</link>
      <pubDate>Tue, 19 May 2015 17:46:00 +0000</pubDate>
      
      <guid>https://serge-m.github.io/posts/double-checked-lock-dcl/</guid>
      <description>http://www.javaworld.com/article/2074979/java-concurrency/double-checked-locking&amp;ndash;clever&amp;ndash;but-broken.html
DCL relies on an unsynchronized use of the resource field. That appears to be harmless, but it is not. To see why, imagine that thread A is inside the synchronized block, executing the statement resource = new Resource(); while thread B is just entering getResource(). Consider the effect on memory of this initialization. Memory for the new Resource object will be allocated; the constructor for Resource will be called, initializing the member fields of the new object; and the field resource of SomeClass will be assigned a reference to the newly created object.</description>
    </item>
    
  </channel>
</rss>
